
\title{One-Bit Maximal Matching on a Ring}
%\author{}
\date{}

\begin{document}

\section{Maximal Matching using Ternary Variables}

A process $P[i]$ can point to itself or either of its neighbors.
Arrange the processes in a bidirectional ring.
The processes form a maximal matching when they point to each other or themselves (though no two neighboring processes can both point to themselves).
Formally, this can be defined with a ternary variable $m[i]$ used by each process $P[i]$.
\begin{code}
(future & silent)
  (forall i <- Int % N :
      m[i-1] == 2 && m[i] == 0                 // P[i] pointing to P[i-1] and P[i-1] pointing back
   || m[i-1] == 0 && m[i] == 1 && m[i+1] == 2  // P[i] pointing to itself and neighbors pointing away
   ||                m[i] == 2 && m[i+1] == 0  // P[i] pointing to P[i+1] and P[i+1] pointing back
  );
\end{code}

One stabilizing protocol has the actions:
\begin{code}
( m[i-1]==2 && m[i]!=0 && m[i+1]!=0 --> m[i]:=0; )
( m[i-1]!=2 && m[i]!=1 && m[i+1]==2 --> m[i]:=1; )
( m[i-1]!=2 && m[i]!=2 && m[i+1]!=2 --> m[i]:=2; )
\end{code}

\section{Maximal Matching using Binary Variables}

Can a matching protocol be performed with only one bit per process?
It seems counterintuitive, since each process needs to be able to point in $3$ directions.
Even so, let's found out if it is possible!

Give each process $P[i]$ a binary $x[i]$ variable to perform the protocol along with a ternary $m[i]$ variable used to specify the invariant.
We use the same invariant as before, but since we are using superposition, we only enforce that a synthesized protocol converges to some invariant $I'$ that is the same as $I$ when projected onto the underlying variables.
\begin{code}
constant N := 4;

// Superposed variables.
puppet variable x[Int % N] <- Int % 2;

// Underlying variables.
direct variable m[Int % N] <- Int % 3;

process P[i <- Int % N]
{
  read: x[i-1];
  write: x[i];
  read: x[i+1];
  write: m[i];
}

((future & shadow) % puppet)
  (forall i <- Int % N :
      m[i-1] == 2 && m[i] == 0
   || m[i-1] == 0 && m[i] == 1 && m[i+1] == 2
   ||                m[i] == 2 && m[i+1] == 0
  );
\end{code}

From synthesis, one of the protocols we get the following.
These actions are simplified for presentation, but the protocol is the same.
\begin{code}
( x[i-1]==1 && x[i]==1 && x[i+1]==1 --> x[i]:=0; m[i]:=0; )
( x[i-1]==0 && x[i]==1 && x[i+1]==1 --> x[i]:=0; m[i]:=1; )
( x[i-1]==0 && x[i]==0 && x[i+1]==0 --> x[i]:=1; m[i]:=2; )

( x[i-1]==1 && x[i]==0              && m[i]!=0 --> m[i]:=0; )
( x[i-1]==0 && x[i]==0 && x[i+1]==1 && m[i]!=1 --> m[i]:=1; )
( x[i-1]==0 && x[i]==1 && x[i+1]==0 && m[i]!=2 --> m[i]:=2; )
\end{code}

From here, we can create the 1-bit matching protocol on the $x[i]$ variables without the $m[i]$s.
The first three actions of the synthesized protocol change $x[i]$ and are therefore used as actions in our 1-bit matching protocol, discarding changes to $m[i]$.
\begin{code}
( x[i-1]==1 && x[i]==1 && x[i+1]==1 --> x[i]:=0; )
( x[i-1]==0 && x[i]==1 && x[i+1]==1 --> x[i]:=0; )
( x[i-1]==0 && x[i]==0 && x[i+1]==0 --> x[i]:=1; )
\end{code}

The invariant is all states where the $x[i]$ values don't change (see the last three actions above).
\begin{code}
(future & silent)
  (forall i <- Int % N :
      x[i-1]==1 && x[i]==0               // P[i] pointing to P[i-1] and P[i-1] pointing back
   || x[i-1]==0 && x[i]==0 && x[i+1]==1  // P[i] pointing to itself and neighbors pointing away
   || x[i-1]==0 && x[i]==1 && x[i+1]==0  // P[i] pointing to P[i+1] and P[i+1] pointing back
  );
\end{code}
Each of these cases in the disjunction corresponds to $P[i]$ pointing to $P[i-1]$, itself, and $P[i+1]$ respectively.
We know this by looking at how $m[i]$ is changed to be \ilcode{m[i]:=0}, \ilcode{m[i]:=1}, and \ilcode{m[i]:=2} in the synthesized protocol.

Note that the third case in the disjunction can be simplified from \ilcode{x[i-1]==0 && x[i]==1 && x[i+1]==0} to \ilcode{x[i]==1 && x[i+1]==0} since if the formula holds for $P[i]$ and the system is in the invariant, then the first or second cases in the disjunction must hold for $P[i-1]$ (hence, $x[i-1]=0$).

Putting this all together, we get:
\codeinputlisting{../../../examplesoln/MatchRingOneBit.prot}

\section{Using Shadow/Puppet Variables}

The specification is best given using shadow/puppet variables, where the shadow variable values cannot affect actions in the synthesized protocol.
\codeinputlisting{../../../examplespec/MatchRingOneBit.prot}

This is effectively the same result as in the previous section, though self-loops formed by fixing the $m[i]$ variables are ignored.
\codeinputlisting{../../../examplesynt/MatchRingOneBit.prot}

It may have been more intuitive to define the matching problem as picking a set of edges without common vertices.
This is also possible using shadow/puppet synthesis.
See the specification \caturl{../}{examplespec/MatchRing.prot} and solution \caturl{../}{examplesynt/MatchRing.prot}.

\section{Proof of Stabilization}

It is fairly easy to show that the 1-bit matching protocol is stabilizing.
First we will show that all executions terminate.
Then we will show that all silent states belong to the invariant.

Recall that each $P[i]$ has the following actions:
\begin{code}
( x[i-1]==0 && x[i]==0 && x[i+1]==0 --> x[i]:=1; )
(              x[i]==1 && x[i+1]==1 --> x[i]:=0; )
\end{code}

We can show the protocol is silent (livelock-free) by analyzing two cases:
(1) If $P[i]$ executes the first action \ilcode{( x[i-1]==0 && x[i]==0 && x[i+1]==0 --> x[i]:=1; )}, then $P[i-1]$, $P[i]$, and $P[i+1]$ will never be enabled again.
(2) Using only the second action \ilcode{( x[i]==1 && x[i+1]==1 --> x[i]:=0; )}, the protocol will not execute indefinitely.

If $P[i]$ executes the first action \ilcode{( x[i-1]==0 && x[i]==0 && x[i+1]==0 --> x[i]:=1; )}, we can show that $P[i-1]$, $P[i]$, and $P[i+1]$ will never be enabled again by analyzing their next possible actions.
Observe that if $x[i-1]==0$, then $P[i-1]$ can only be enabled if $x[i-2]==0$ and $x[i]==0$.
Likewise, if $x[i+1]==0$, then $P[i+1]$ can only be enabled if $x[i]==0$ and $x[i+2]==0$.
However, since $x[i]==1$, both $P[i-1]$ and $P[i+1]$ are disabled until $P[i]$ assigns $x[i+1]:=0$.
Since $P[i]$ is disabled as well, having $x[i]==1$, all three processes will remain disabled indefinitely.

Now we know that the first action cannot be involved in a livelock.
Since there are only two actions in the protocol, if there is a livelock, it can exist only by processes executing the second action \ilcode{( x[i]==1 && x[i+1]==1 --> x[i]:=0; )}.
However, since this action strictly changes $x[i]$ values around the ring from $1$ to $0$, eventually there will not be any $1$ values next to each other.
Therefore, this action cannot form a livelock.

Since the first action guarantees that a process is forever disabled, and processes executing the second action cannot form a livelock, the 1-bit matching protocol is livelock-free.
It remains to show that the set of silent states is exactly the invariant:
\begin{code}
(forall i <- Int % N :
    x[i-1]==1 && x[i]==0               // P[i] pointing to P[i-1] and P[i-1] pointing back
 || x[i-1]==0 && x[i]==0 && x[i+1]==1  // P[i] pointing to itself and neighbors pointing away
 ||              x[i]==1 && x[i+1]==0  // P[i] pointing to P[i+1] and P[i+1] pointing back
)
\end{code}
This can be shown by observing the protocol's actions flip a bit whenever there are $3$ consecutive $0$s or $2$ consecutive $1$s in the ring.
That is, the silent states allow at most $2$ consecutive $0$ values at a time before a $1$ occurs, and no consecutive $1$ values are allowed.
We can see the invariant for 1-bit matching has cases for $x[i]==0$ and $x[i]==1$.
When $x[i]==0$, the previous value in the ring can be either $x[i-1]==0$ or $x[i-1]==1$.
However, when $x[i-1]==0 && x[i]==0$, the invariant requires that $x[i+1]==1$ to avoid more than $2$ consecutive $0$ values.
When $x[i]==1$, the invariant requires that $x[i+1]==0$ to avoid any consecutive $1$ values.
The 1-bit matching invariant is identical to the silent states, therefore the protocol has no deadlocks.

We have shown livelock freedom and deadlock freedom for the 1-bit matching protocol.
Thus, the 1-bit matching protocol is self-stabilizing.

\end{document}

