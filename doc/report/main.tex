
\input{preamble}

\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{algorithm}
\usepackage{algorithmic}

\setlength{\abovedisplayskip}{0.5em}
\setlength{\abovedisplayshortskip}{0.5em}
\setlength{\belowdisplayskip}{0.5em}
\setlength{\belowdisplayshortskip}{0.5em}
\setlength{\abovecaptionskip}{0.0em}
\setlength{\belowcaptionskip}{0.0em}

\def\imagetop#1{\vtop{\null\hbox{#1}}}

\newcommand{\xnsysinst}[3]{%
\begin{figure}[H]
\begin{tabular}[c]{l|l}
 \imagetop{#2} &
 \imagetop{\begin{tabular}[c]{@{}l@{}}#3\end{tabular}} \\
\end{tabular}
\caption{Problem instance: \texttt{#1}}
\end{figure}}

\newcommand{\unique}{\exists!}

\begin{document}
\title{
 CS5811 Report:\\
 Search for Self-Stabilizing Protocols
}

\author{~Brandon~Crowley\and~Alex~Klinkhamer\and~Man~Wang}
\maketitle

\newpage
\tableofcontents
\newpage

\section{Project Description}

\subsection{AddConvergence Problem}

Given a network of processes (finite-state machines) and an invariant $I$ (i.e., legitimate states) over their variables, find a set of actions for the processes which guarantees every computation from any initial global state will eventually reach the invariant (i.e., {\it convergence}).
Additionally, once the system is in an invariant state, it must never leave (i.e., {\it closure}).

For each process $P_i$, network topology defines the variables which $P_i$ owns and which other variables $P_i$ can read.
A process can read and write its own variables and may only read the variables of other processes.
The purpose of a process is to act.
A process can have actions of the form $\mathit{guard} \to \mathit{assignment}$ where $\mathit{guard}$ is a predicate over the readable variables of $P_i$ and $\mathit{assignment}$ is a variable assignment.
\begin{enumerate}
\item If $P_i$ sees a guard is satisfied, it performs the appropriate variable assignment.
 \begin{enumerate}
 \item Note that another process may reassign its variable before $P_i$ can act!
 \end{enumerate}
\item The read/write cycle of an action happens atomically. This is interleaving semantics and we can assume that at most one read/write cycle of an action is happening at any given time.
\item If a process does not have a guard which is satisfied, it does not act.
\item If no two guards can be satisfied at the same time, the process is deterministic.
\end{enumerate}

We can represent actions in the finest possible granularity by considering only local transitions.
For example, if process $P_1$ can read $x_0$ and $x_1$, each spanning $\aset{0,1,2}$, and write $x_1$, then an action 
\[ x_1 = 0 \wedge x_0 = 2 \to x_1 \defeq 1; \]
is a local transition from $(x_1 = 0 \wedge x_0 = 2)$ to $(x_1 = 1 \wedge x_0 = 2)$.
We would not consider an action such as
\[ x_1 = 0 \to x_1 \defeq 1; \]
for $P_1$ because it represents $3$ local transitions:
from $(x_1 = 0 \wedge x_0 = 0)$ to $(x_1 = 1 \wedge x_0 = 0)$,
from $(x_1 = 0 \wedge x_0 = 1)$ to $(x_1 = 1 \wedge x_0 = 1)$,
and from $(x_1 = 0 \wedge x_0 = 2)$ to $(x_1 = 1 \wedge x_0 = 2)$.

\subsection{AddConvergence as a Graph Problem}

We can think of a graph where each vertex corresponds with a global state in the system.
An action is represented by several directed edges, each with the same label.
Next mark all global states which satisfy the invariant.

The problem of adding convergence to a system (finding a self-stabilizing protocol) is the same as finding a set of labels for which the set of all edges with those labels:
\begin{enumerate}
\item Does not include edges from a vertex marked as invariant to a vertex not marked as invariant.
 \begin{enumerate}
 \item Closure.
 \end{enumerate}
\item Form a path from each vertex not marked as invariant to a vertex marked as invariant.
 \begin{enumerate}
 \item Weak-convergence.
 \end{enumerate}
\item Does not form cycles among the vertices not marked as invariant.
 \begin{enumerate}
 \item Livelock freedom.
 \end{enumerate}
\end{enumerate}

Sometimes no edges are allowed from any invariant states.

\subsection{Example: Sum-Not-2}

Consider the Sum-Not-2 instance on $3$ processes.
Each process $P_i$ owns a variable $x_i\in\Nat_3$ (where $\Nat_3 = \aset{0,1,2}$).
Processes are in a unidirectional ring meaning each $P_i$ can read its anticlockwise neighbor $P_{i-1}$ (subtraction is modulo $3$).
The invariant is all states where no $x_i + x_{i-1} = 2$, so $I \equiv (\forall i\in\Nat_3: x_i + x_{i-1} \ne 2)$.

Illustrated in the three figures are the problem instance, a stabilizing protocol, and how that protocol appears as a transition graph over the global state space.
\begin{figure}[H]
\begin{tabular}{l|l}
\begin{tikzpicture}[x=1.5cm,y=1.5cm]
\tikzstyle{every node}=[]
\draw
 (0,0)      node (0) {$P_0$}
 ++( -60:1) node (1) {$P_1$}
 ++(-180:1) node (2) {$P_2$}
 ;
\path[->,draw,thick]
(0) edge (1)
(1) edge (2)
(2) edge (0)
;
\end{tikzpicture}
&
\begin{tabular}[b]{@{}l@{}}
For all $i\in\Nat_3$, $P_i$ has privileges:
\\
\begin{centering}
$P_i :
\begin{cases}
 x_i\in\Nat_3 & \mbox{(read-write)} \\
 x_{i-1}\in\Nat_3 & \mbox{(read-only)} \\
\end{cases}$
\end{centering}
\\
Invariant:
$I \equiv (\forall i\in\Nat_3: x_i + x_{i-1} \ne 2)$
\end{tabular}
\\
\end{tabular}
\caption{Sum-Not-2 problem instance.}
\end{figure}

\begin{figure}[H]
\begin{eqnarray*}
   (x_i = 0) \wedge (x_{i-1} = 2) & \to & x_i \defeq 1;
\\ (x_i = 1) \wedge (x_{i-1} = 1) & \to & x_i \defeq 0;
\\ (x_i = 2) \wedge (x_{i-1} = 0) & \to & x_i \defeq 0;
\end{eqnarray*}
\caption{Actions of each $P_i$ in a stabilizing protocol for Sum-Not-2.}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[x=1.0cm,y=1.0cm]
\tikzstyle{every node}=[]
\tikzstyle{legit}=[draw]
\def \dx {3.5}
\draw
  (  0, 0) node [legit] (000) {000}
++(\dx, 0) node [legit] (100) {100}
++(\dx, 0) node         (200) {200}
  (  0,-1) node [legit] (010) {010}
++(\dx, 0) node         (110) {110}
++(\dx, 0) node         (210) {210}
  (  0,-2) node         (020) {020}
++(\dx, 0) node         (120) {120}
++(\dx, 0) node         (220) {220}
  (  1, 0) node [legit] (001) {001}
++(\dx, 0) node         (101) {101}
++(\dx, 0) node         (201) {201}
  (  1,-1) node         (011) {011}
++(\dx, 0) node         (111) {111}
++(\dx, 0) node         (211) {211}
  (  1,-2) node         (021) {021}
++(\dx, 0) node         (121) {121}
++(\dx, 0) node [legit] (221) {221}
  (  2, 0) node         (002) {002}
++(\dx, 0) node         (102) {102}
++(\dx, 0) node         (202) {202}
  (  2,-1) node         (012) {012}
++(\dx, 0) node         (112) {112}
++(\dx, 0) node [legit] (212) {212}
  (  2,-2) node         (022) {022}
++(\dx, 0) node [legit] (122) {122}
++(\dx, 0) node [legit] (222) {222}
;
\path[->,draw,thick]
(002) edge [color=red!40,out=- 20,in= 200,looseness=.7] (102)
(012) edge [color=red!40,out=- 20,in= 200,looseness=.7] (112)
(022) edge [color=red!40,out=- 20,in= 200,looseness=.7] (122)
(101) edge [color=red!40,out= 140,in=  30,looseness=.6] (001)
(111) edge [color=red!40,out= 140,in=  30,looseness=.6] (011)
(121) edge [color=red!40,out= 140,in=  30,looseness=.6] (021)
(200) edge [color=red!40,out= 160,in=  70,looseness=.3] (000)
(210) edge [color=red!40,out= 160,in=  70,looseness=.3] (010)
(220) edge [color=red!40,out= 160,in=  70,looseness=.3] (020)

(200) edge [color=green!50!black!75,out=-120,in= 120] (210)
(201) edge [color=green!50!black!75,out=-120,in= 120] (211)
(202) edge [color=green!50!black!75,out=-120,in= 120] (212)
(110) edge [color=green!50!black!75,out=  50,in=- 50] (100)
(111) edge [color=green!50!black!75,out=  50,in=- 50] (101)
(112) edge [color=green!50!black!75,out=  50,in=- 50] (102)
(020) edge [color=green!50!black!75,out= 140,in=-140,looseness=.5] (000)
(021) edge [color=green!50!black!75,out= 130,in=-130,looseness=.5] (001)
(022) edge [color=green!50!black!75,out= 130,in=-130,looseness=.5] (002)

(002) edge [color=blue,out= 120,in=  40,looseness=.5] (000)
(102) edge [color=blue,out= 120,in=  40,looseness=.5] (100)
(202) edge [color=blue,out= 120,in=  40,looseness=.5] (200)
(011) edge [color=blue,out= 130,in=  60] (010)
(111) edge [color=blue,out= 130,in=  60] (110)
(211) edge [color=blue,out= 130,in=  60] (210)
(020) edge [color=blue,out=- 60,in= 230] (021)
(120) edge [color=blue,out=- 60,in= 230] (121)
(220) edge [color=blue,out=- 60,in= 230] (221)
;
\end{tikzpicture}
\caption{Transitions of {\color{red!40} $P_0$}, {\color{green!50!black!75} $P_1$}, {\color{blue} $P_2$}. Legitimate states $x_0x_1x_2$ are boxed.}
\end{figure}

\subsection{Relation to Artificial Intelligence}

The problem of adding convergence is NP-complete in the number of candidate actions (which can be polynomially related to the number of states).

We used techniques from constraint satisfaction problems to get a complete algorithm for AddConvergence.

\subsection{Algorithm}
\subsubsection{Search Initialization}
\begin{enumerate}
\item Let $\vbl{candidates}$ be a list of all actions.
\item Prune all actions which are self-loops from $\vbl{candidates}$.
 \begin{enumerate}
 \item[] Example self-loop: $x_1 = 1 \wedge x_0 = 0 \to x_1\defeq 1$.
 \end{enumerate}
\item Prune all actions which break closure from $\vbl{candidates}$.
\item Let $\vbl{actions}$ be an empty list actions.
\item Call backtracking algorithm.
\end{enumerate}

\subsubsection{Backtracking}
\begin{enumerate}
\item If all deadlocks in illegitimate states are resolved by $\vbl{actions}$, return success!
\item While $\vbl{actions}\cup\vbl{candidates}$ weakly converge to the invariant,
 \begin{enumerate}
 \item Pick an action $B\in\vbl{candidates}$ using most-constrained deadlock heuristic.
 \item Let $\vbl{actions'} \defeq \vbl{actions} \cup \aset{B}$.
 \item Let $\vbl{candidates'} \defeq \vbl{candidates} \setminus \aset{B}$.
 \item Perform forward checking on $\vbl{actions'}$ and $\vbl{candidates'}$ to shrink $\vbl{candidates'}$.
 \item {\bf Recurse} with $\vbl{actions'}$ and $\vbl{candidates'}$.
 \item If solution was found, return success!
 \item Assign $\vbl{candidates}\defeq\vbl{candidates}\setminus\aset{B}$.
 \item Add any actions to $\vbl{actions}$ from $\vbl{candidates}$ which now required to resolve deadlocks.
 \item If any were added, perform forward checking on $\vbl{actions}$ and $\vbl{candidates}$ to shrink $\vbl{candidates}$.
 \end{enumerate}
\end{enumerate}

\subsubsection{Forward Checking}

Having added an action $A$ of process $P_i$, test each remaining candidate action $B$.
$B$ is pruned if either:
\begin{enumerate}
\item $B$ is an action of $P_i$ and enables $A$. For example,
 \begin{itemize}
 \item[] Action $B$ is $x_1 = 0 \wedge x_0 = 0 \to x_1\defeq 1$.
 \item[] Action $A$ is $x_1 = 1 \wedge x_0 = 0 \to x_1\defeq 2$.
 \item Action $x_1 = 0 \wedge x_0 = 0 \to x_1\defeq 2$ could be used instead of $B$ if we want this behavior. $B$ is useless!
 \end{itemize}
\item $B$ is an action of $P_i$ and is enabled by $A$, for example,
 \begin{itemize}
 \item[] Action $A$ is $x_1 = 1 \wedge x_1 = 0 \to x_1\defeq 2$.
 \item[] Action $B$ is $x_1 = 2 \wedge x_1 = 0 \to x_1\defeq 0$.
 \item Action $x_1 = 1 \wedge x_0 = 0 \to x_1\defeq 0$ would have been used instead of $A$ if we wanted this behavior. $B$ is useless!
 \end{itemize}
\item $B$ does not resolve any new deadlocks.
\item $B$ would create a cycle (livelock) outside of the invariant.
\end{enumerate}

\subsubsection{Most-Constrained Deadlocks}

\begin{enumerate}
\item Order the sets of deadlocks by number of candidate actions which can resolve them.
\item When picking the next candidate action, pick one which resolves one of the most constrained deadlocks!
 \begin{itemize}
 \item Use greedy approach to choose the candidate action from those which can resolve the most-constrained deadlocks. That is, pick the action which has the ``most influence''.
  \begin{itemize}
  \item Loosely related to resolving most deadlocks.
  \item Measured by least number of conflicting candidate actions.
  \item Performs better than any Least-Constraining Value (LCV) heuristic that we could figure out.
  \end{itemize}
 \end{itemize}
\item To further help picking, define an order to processes.
 \begin{itemize}
 \item Prefer actions of processes which appear earliest in this order.
 \item Sometimes a {\it backwards} ordering ($P_{N-1},\dots,P_0$) is preferred on a unidirectional ring.
 \end{itemize}
\end{enumerate}

\section{Background}

\subsection{Multi-Value Decision Diagram}
As in regular software or any search algorithm, the states could be of large amount and rather complex. Simply listing the states is inefficient and complicates analysis. Here we resort to Multiple-Valued Logic for describing the state of a system, represented by a multi-valued decision diagram (MDD), which is a multi-valued version of the binary decision diagram (BDD).
This allows countermeasures to be formated that address states that share common features. 

MDDs provide a uniform way to represent formulas which evaluate to {\it true} or {\it false} based on variable values (i.e., predicate functions).
We use them because they can also use {\em much less} space than a truth-table.
BDDs and MDDs differ only by the domains of variables. BDDs only allows boolean variables, so they can express the input formulas of the satisfiability problem.
MDDs, on the other hand, allow variables to have finite domains (conventionally represented by natural numbers starting at $0$).
As any integer can be represented by string of bits, MDDs can be implemented using BDDs.

Consider a predicate over three variables $x, y, z$, each with values ranging from $0$ to $4$ (domain size 3). Initially, there are $5^3 = 125$ states in the system. If we specify the state predicate as $x=3$, the number of states for which the predicate returns {\it true} is $25$, since the value of $x$ is totally fixed. We could use an MDD to symbolically represent this set of $25$ states.

Now we have a rough format close to the format representing the protocol states later on. Say there are 3 processes arranged in the bidirectional ring, and each node could read from its two neighbors and write to itself. Actually, with three processes in a bidirectional ring, each process can read all variables, but the small state-space is convenient for this example. We use $m_0$ as the variable of $P_0$. $m'_0$ means the same except the value is the one in the next time step. Similarly, this rule applies to processes $P_1$ and $P_2$. The following predicate represents a transition function for this system:
\begin{eqnarray*}
 & & m_0 = 0 \wedge m'_0 = 0 \wedge m_1 = 0 \wedge m'_1 = 1 \wedge m_2 = 1 \wedge m'_2 = 1 \\
 & \vee & m_0 = 0 \wedge m'_0 = 0 \wedge m_1 = 2 \wedge m'_1 = 1 \wedge m_2 = 1 \wedge m'_2 = 1
\end{eqnarray*}
After checking the values of each process, it is obvious that there are some variables which will change their values as time goes on. The value of $m_1$ can change to $1$ from $0$ when $m_0 = 0 \wedge m_1 = 0 \wedge m_2 = 1$. The value of $m_1$ can also change to $1$ from $2$ when $m_0 = 0 \wedge m_1 = 2 \wedge m_2$. This shows how to represent a transition function with satisfying valuations of unprimed and primed variables.

The following algorithms use set notation, which directly translates to MDD operations.
For example: complement translates to negation, intersection translates to conjunction, and union translates to disjunction.

\subsubsection{Image and Preimage}

The $\vbl{image}(T,S)$ function finds all states which transitions $T$ map from $S$.
\[ \vbl{image}(T,S) = \aset{s_1 \pipe\exists s_0\in S : (s_0,s_1)\in T} \]

The $\vbl{preimage}$ function is the reverse.
It finds all states which are mapped to states in $S$ by transitions $T$.
\[ \vbl{preimage}(T,S) = \aset{s_0 \pipe\exists s_1\in S : (s_0,s_1)\in T} \]

Both $\vbl{image}$ and $\vbl{preimage}$ can be written in terms of MDD operations.

\subsubsection{Weak Convergence}

When checking for weak convergence, we are looking that a path exists from every state outside of the invariant to a state in the invariant.
This algorithm performs backwards reachability from the invariant and returns success if and only if all states can be reached.

\begin{algorithm}[H]{WeakConvergenceCk($T$, $I$)} 
\caption{WeakConvergenceCk} 
\begin{algorithmic}
\STATE $S_0 \defeq I$
\WHILE{$\overline{S_0} \neq \emptyset$}
 \STATE $S_1 \defeq S_0 \cup \vbl{preimage}(T, S_0)$
 \IF{$S_1 = S_0$}
  \RETURN \FALSE
 \ENDIF
 \STATE $S_0 \defeq S_1$
\ENDWHILE
\RETURN \TRUE
\end{algorithmic}
\end{algorithm}

\subsubsection{Cycle Detection}

Check for cycles outside of the invariant by computing the fixed point of the $\vbl{preimage}$ function.
This is the Emerson-Lei algorithm as written in \cite{Fisler:2001:BSC:646485.694446}, but originally from \cite{DBLP:conf/lics/EmersonL86}.
We assume the protocol is closed in the invariant, so we do not need to worry about invariant states being in the preimage.

\begin{algorithm}[H]{CycleCk($T$, $I$)} 
\caption{CycleCk} 
\begin{algorithmic}
\STATE $S_0 \defeq \overline{I}$
\STATE $S_1 \defeq \emptyset$
\REPEAT
 \STATE $S_1 \defeq S_0$
 \STATE $S_0 \defeq S_0 \cap \vbl{preimage}(T,S)$
\UNTIL{$S_0 = S_1$}

\IF{$S_0 = \emptyset$}
 \RETURN \TRUE
\ELSE
 \RETURN \FALSE
\ENDIF
\end{algorithmic}
\end{algorithm}

%\begin{algorithm}{BackwardReachability($T$, $S_1$)}
%\caption{BackwardReachability} 
%\begin{algorithmic}
%\STATE $S_0 \defeq S_1$
%\STATE $L \defeq \vbl{preimage}(T, S_0) - S_0$
%\WHILE{$L \ne \emptyset$}
% \STATE $S_0 \defeq S_0 \cup L$
% \STATE $L \defeq \vbl{preimage}(T, L) - S_0$
%\ENDWHILE
%\RETURN $S_0$
%\end{algorithmic}
%\end{algorithm}

\subsection{Process Ordering}

We used the idea from \cite{ipdpsEbnenasir11} to impose an ordering on the actions we choose for each recursion level in the backtracking algorithm.
For the Dijkstra's token ring experiment, this made a big difference.
We imposed a preference to pick candidate actions of the highest numbered process available.

%* Background: related literature and software and algorithms that you imported into your project. Clearly describe, work that you directly used, work you used after modification, and your own contribution.

%* Comparison to similar projects

\section{Examples}
Some examples of stabilizing protocols follow.
We plan to use these (and more) in our experimentation.

We should also try to use reduction to SAT on these problems, but encoding cycle detection in a CNF formula blows up quickly in size.
In the worst case, we require $O(\abs{S_p}^3)$ where $S_p$ is set of all states.
Our tool should outperform the reduction to SAT purely due to its exploding size.

\subsection{Sum-Not-2}

\xnsysinst{sum-not-2}{
\begin{tikzpicture}[x=1.5cm,y=1.5cm]
\tikzstyle{every node}=[]
 \draw
 (0,0)      node (0) {$P_0$}
 ++(   0:1) node (1) {$P_1$}
 ++( -60:1) node (2) {$P_2$}
 ++(-120:1) node (3) {$P_3$}
 ++(-180:1) node (4) {$P_4$}
 ++(-240:1) node (5) {$P_{n-1}$}
 ;
 \path[->,draw,thick]
 (0) edge (1)
 (1) edge (2)
 (2) edge (3)
 (3) edge (4)
 (5) edge (0)
 ;
 \path[->,draw,thick,dotted]
 (4) edge (5)
 ;
\end{tikzpicture}
}{
For all $i\in\Nat_n$, $P_i$ has privileges:
\\
\begin{centering}
$P_i :
\begin{cases}
 x_i\in\Nat_3 & \mbox{(read-write)} \\
 x_{i-1}\in\Nat_3 & \mbox{(read-only)} \\
\end{cases}$
\end{centering}
\\
Invariant:
$I \equiv (\forall i\in\Nat_n: x_i + x_{i-1} \ne 2)$
}

\subsection{2-Coloring}

\xnsysinst{2-coloring}{
\begin{tikzpicture}[x=1.5cm,y=1.5cm]
\tikzstyle{every node}=[]
 \draw
 (0,0)      node (0) {$P_0$}
 ++(   0:1) node (1) {$P_1$}
 ++( -60:1) node (2) {$P_2$}
 ++(-120:1) node (3) {$P_3$}
 ++(-180:1) node (4) {$P_4$}
 ++(-240:1) node (5) {$P_{n-1}$}
 ;
 \path[->,draw,thick]
 (0) edge (1)
 (1) edge (2)
 (2) edge (3)
 (3) edge (4)
 (5) edge (0)
 ;
 \path[->,draw,thick,dotted]
 (4) edge (5)
 ;
\end{tikzpicture}
}{
For all $i\in\Nat_n$, $P_i$ has privileges:
\\
\begin{centering}
$P_i :
\begin{cases}
 c_i\in\Nat_2 & \mbox{(read-write)} \\
 c_{i-1}\in\Nat_2 & \mbox{(read-only)} \\
\end{cases}$
\end{centering}
\\
Invariant:
\begin{centering}
$I \equiv (\forall i\in\Nat_n: c_{i-1}\ne c_i)$
\end{centering}
}

\subsection{3-Coloring}

\xnsysinst{3-coloring}{
\begin{tikzpicture}[x=1.5cm,y=1.5cm]
\tikzstyle{every node}=[]
 \draw
 (0,0)      node (0) {$P_0$}
 ++(   0:1) node (1) {$P_1$}
 ++( -60:1) node (2) {$P_2$}
 ++(-120:1) node (3) {$P_3$}
 ++(-180:1) node (4) {$P_4$}
 ++(-240:1) node (5) {$P_{n-1}$}
 ;
 \path[draw,thick]
 (0) edge (1)
 (1) edge (2)
 (2) edge (3)
 (3) edge (4)
 (5) edge (0)
 ;
 \path[draw,thick,dotted]
 (4) edge (5)
 ;
\end{tikzpicture}
}{
For all $i\in\Nat_n$, $P_i$ has privileges:
\\
\begin{centering}
$P_i :
\begin{cases}
 c_i\in\Nat_3 & \mbox{(read-write)} \\
 c_{i-1}\in\Nat_3 & \mbox{(read-only)} \\
 c_{i+1}\in\Nat_3 & \mbox{(read-only)} \\
\end{cases}$
\end{centering}
\\
Invariant:
\begin{centering}
$I \equiv (\forall i\in\Nat_n: c_i\ne c_{i-1} \wedge c_i\ne c_{i+1})$
\end{centering}
}

Let each process $P_i$ in a bidirectional ring of $n$ processes have a variable $c_i\in \Nat_3$ (i.e., $c_i\in \{0,1,2\}$) where each of the three values represents a different color, like {\it red}, {\it green}, and {\it blue}.
Since this is a bidirectional ring, any $P_i$ can read its left and right neighbors' variables $c_{i-1}$ and $c_{i+1}$.
$P_i$ can also read and write its own variable $c_i$.

The system is in a legitimate state when no two neighboring processes have the same color.

The following action for each $P_i$ can be used for a stabilizing protocol:
\[
 (c_{i-1} = c_i) \vee (c_i = c_{i+1}) \to c_i \defeq \textsc{Other}(c_{i-1}, c_{i+1})
\]
where the \textsc{Other} function returns a color (deterministically, say the minimal-valued one) which is not equal to either of its inputs.

We expect our tool to synthesize actions in their most basic form, as local state transitions.
The above action can be expressed by the following $15$ local state transitions for $P_i$:
\begin{eqnarray*}
 c_{i-1} = 0 \wedge c_i = 0 \wedge c_{i+1} = 0 & \to & c_i \defeq 1 \\
 c_{i-1} = 0 \wedge c_i = 0 \wedge c_{i+1} = 1 & \to & c_i \defeq 2 \\
 c_{i-1} = 1 \wedge c_i = 0 \wedge c_{i+1} = 0 & \to & c_i \defeq 2 \\
 c_{i-1} = 2 \wedge c_i = 0 \wedge c_{i+1} = 0 & \to & c_i \defeq 1 \\
 c_{i-1} = 0 \wedge c_i = 0 \wedge c_{i+1} = 2 & \to & c_i \defeq 1 \\
 c_{i-1} = 1 \wedge c_i = 1 \wedge c_{i+1} = 1 & \to & c_i \defeq 0 \\
 c_{i-1} = 1 \wedge c_i = 1 \wedge c_{i+1} = 0 & \to & c_i \defeq 2 \\
 c_{i-1} = 0 \wedge c_i = 1 \wedge c_{i+1} = 1 & \to & c_i \defeq 2 \\
 c_{i-1} = 1 \wedge c_i = 1 \wedge c_{i+1} = 2 & \to & c_i \defeq 0 \\
 c_{i-1} = 2 \wedge c_i = 1 \wedge c_{i+1} = 1 & \to & c_i \defeq 0 \\
 c_{i-1} = 2 \wedge c_i = 2 \wedge c_{i+1} = 2 & \to & c_i \defeq 0 \\
 c_{i-1} = 2 \wedge c_i = 2 \wedge c_{i+1} = 0 & \to & c_i \defeq 1 \\
 c_{i-1} = 0 \wedge c_i = 2 \wedge c_{i+1} = 2 & \to & c_i \defeq 1 \\
 c_{i-1} = 2 \wedge c_i = 2 \wedge c_{i+1} = 1 & \to & c_i \defeq 0 \\
 c_{i-1} = 1 \wedge c_i = 2 \wedge c_{i+1} = 2 & \to & c_i \defeq 0
\end{eqnarray*}

\subsection{Maximal Matching}

\xnsysinst{matching}{
\begin{tikzpicture}[x=1.5cm,y=1.5cm]
 \tikzstyle{every node}=[]
 \draw
 (0,0)      node (0) {$P_0$}
 ++(   0:1) node (1) {$P_1$}
 ++( -60:1) node (2) {$P_2$}
 ++(-120:1) node (3) {$P_3$}
 ++(-180:1) node (4) {$P_4$}
 ++(-240:1) node (5) {$P_{n-1}$}
 ;
 \path[draw,thick]
 (0) edge (1)
 (1) edge (2)
 (2) edge (3)
 (3) edge (4)
 (5) edge (0)
 ;
 \path[draw,thick,dotted]
 (4) edge (5)
 ;
\end{tikzpicture}
}{
For all $i\in\Nat_n$, $P_i$ has privileges:
\\
\begin{centering}
$P_i :
\begin{cases}
 m_i\in\Nat_3 & \mbox{(read-write)} \\
 m_{i-1}\in\Nat_3 & \mbox{(read-only)} \\
 m_{i+1}\in\Nat_3 & \mbox{(read-only)} \\
\end{cases}$
\end{centering}
\\
Invariant:
\\
\begin{centering}
$\begin{array}{rcl}
 I \equiv \forall i\in\Nat_n: & & (m_{i-1} = 2 \wedge m_i = 1)
\\ & \vee  & (m_{i-1} = 1 \wedge m_i = 0 \wedge m_{i+1} = 2)
\\ & \vee  & (m_i = 2 \wedge m_{i+1} = 1)
\end{array}$
\end{centering}
}

Let each process $P_i$ in a bidirectional ring of $n$ processes have a variable $m_i\in \Nat_3$ (i.e., $m_i\in \{0,1,2\}$) where each of the three values represents a different direction, like {\it self} ($m_i=0$), {\it left} ($m_i=1$), and {\it right} ($m_i=2$).
Since this is a bidirectional ring, any $P_i$ can read its left and right neighbors' variables $m_{i-1}$ and $m_{i+1}$.
$P_i$ can also read and write its own variable $m_i$.

The system is in a legitimate state when neighbors pair up by pointing at each other.
If both neighbors are pointing away, a process can point at itself.


\subsection{Dijkstra's Token Ring \cite{dij}}

\xnsysinst{dijkstra-tr}{
\begin{tikzpicture}[x=1.5cm,y=1.5cm]
 \tikzstyle{every node}=[]
 \draw
 (0,0)      node (0) {$P_0$}
 ++(   0:1) node (1) {$P_1$}
 ++( -60:1) node (2) {$P_2$}
 ++(-120:1) node (3) {$P_3$}
 ++(-180:1) node (4) {$P_4$}
 ++(-240:1) node (5) {$P_{n-1}$}
 ;
 \path[->,draw,thick]
 (0) edge (1)
 (1) edge (2)
 (2) edge (3)
 (3) edge (4)
 (5) edge (0)
 ;
 \path[->,draw,thick,dotted]
 (4) edge (5)
 ;
\end{tikzpicture}
}{
For all $i\in\Nat_n$, $P_i$ has privileges:
\\
\begin{centering}
$P_i :
\begin{cases}
 x_i\in\Nat_{n+1} & \mbox{(read-write)} \\
 x_{i-1}\in\Nat_{n+1} & \mbox{(read-only)} \\
\end{cases}$
\end{centering}
\\
Invariant:
\\
\begin{centering}
$I\equiv (\mbox{$\unique i\in\Nat_n$: $\mathtt{token?}(i)$})$
\end{centering}
\\
\begin{centering}
$\mathtt{token?}(i) = \begin{cases}
   x_i = x_{i-1} & i = 0
\\ x_i \ne x_{i-1} & i \ne 0
\end{cases}$
\end{centering}
}
Note: $\unique i\in\Nat_n: \phi(i)$ means that there exists exactly one $i$ for which the predicate $\phi(i)$ is satisfied.

A token ring is used to give one process out of many an exclusive right, also known as distributed mutual exclusion.
Each process $P_i$ holds a variable $x_i$ which ranges from $0$ to $n$ ($x_i\in\Nat_{n+1}$).
Each $P_i$ can read and write $x_i$ and can read $x_{i-1}$ (where subtraction is modulo $n$).
Note that each process can only read its left neighbor, so we call this ring {\em unidirectional}.

$P_0$ is said to have a token when it sees $x_{n-1} = x_0$.
Any other $P_i$ has a token when $x_{i-1} \neq x_i$.

A state is legitimate when exactly one process has the token.

\subsection{2-Bit Token ``Spring'' \cite{dij}}

\xnsysinst{2-bit-tr}{
\begin{tikzpicture}[x=1.5cm,y=1.5cm]
  \tikzstyle{every node}=[]
  \draw
  (0,0)      node (0) {$P_0$}
  ++( -30:1) node (1) {$P_1$}
  ++( -90:1) node (2) {$P_2$}
  ++(-150:1) node (3) {$P_3$}
  ++(-210:1) node (4) {$P_4$}
  ++(-270:1) node (5) {$P_{n-1}$}
  ;
  \path[draw,thick]
  (0) edge (1)
  (1) edge (2)
  (2) edge (3)
  (3) edge (4);
  \path[draw,thick,dotted]
  (4) edge (5);
\end{tikzpicture}
}{
For all $i\in\Nat_n$, $P_i$ has privileges:
\\
\begin{centering}
$P_i :
\begin{cases}
   x_i\in\Nat_2 & \mbox{(read-write)}
\\ \vbl{up}_i\in\Nat_2 & \mbox{(read-write)}
\\ x_{i-1}\in\Nat_2 & \mbox{(read-only) when $i>0$}
\\ x_{i+1}\in\Nat_2 & \mbox{(read-only) when $i<n-1$}
\\ \vbl{up}_{i+1}\in\Nat_2 & \mbox{(read-only) when $i<n-1$}
\end{cases}$
\end{centering}
\\
Invariant:
\\
\begin{centering}
$I\equiv (\mbox{$\unique i\in\Nat_n$: $\mathtt{token?}(i)$}) \wedge \vbl{up}_0 = 1 \wedge \vbl{up_1} = 0$
\end{centering}
\\
\begin{centering}
$\mathtt{token?}(i) = \begin{cases}
   x_i = x_{i+1} \wedge \vbl{up}_{i+1} = 0 & i = 0
\\ x_i = x_{i+1} \wedge \vbl{up}_i = 1 \wedge \vbl{up}_{i+1} = 0 & 0<i<n-1
\\ x_i \ne x_{i-1} & 0 < i
\end{cases}$
\end{centering}
}
Note: $\unique i\in\Nat_n: \phi(i)$ means that there exists exactly one $i$ for which the predicate $\phi(i)$ is satisfied.

\subsection{3-Bit Token Rring \cite{Gouda:3bitTR}}

\xnsysinst{3-bit-tr}{
\begin{tikzpicture}[x=1.5cm,y=1.5cm]
 \tikzstyle{every node}=[]
 \draw
 (0,0)      node (0) {$P_0$}
 ++(   0:1) node (1) {$P_1$}
 ++( -60:1) node (2) {$P_2$}
 ++(-120:1) node (3) {$P_3$}
 ++(-180:1) node (4) {$P_4$}
 ++(-240:1) node (5) {$P_{n-1}$}
 ;
 \path[->,draw,thick]
 (0) edge (1)
 (1) edge (2)
 (2) edge (3)
 (3) edge (4)
 (5) edge (0)
 ;
 \path[->,draw,thick,dotted]
 (4) edge (5)
 ;
\end{tikzpicture}
}{
For all $i\in\Nat_n$, $P_i$ has privileges:
\\
\begin{centering}
$P_i :
\begin{cases}
 e_i\in\Nat_2 & \mbox{(read-write)}
\\ t_i\in\Nat_2 & \mbox{(read-write)}
\\ \vbl{ready}_i\in\Nat_2 & \mbox{(read-write)}
\\ e_{i-1}\in\Nat_2 & \mbox{(read-only)}
\\ t_{i-1}\in\Nat_2 & \mbox{(read-only)}
\end{cases}$
\end{centering}
\\
Invariant:
\\
\begin{centering}
$I\equiv (\mbox{$\unique i\in\Nat_n$: $\mathtt{t\_token?}(i)$})\wedge(\exists i\in\Nat_n: \mathtt{e\_token?}(i))$
\end{centering}
\\
\begin{centering}
$\mathtt{e\_token?}(i) = \begin{cases}
   e_i = e_{i-1} & i = 0
\\ e_i \ne e_{i-1} & i \ne 0
\end{cases}$
\end{centering}
\\
\begin{centering}
$\mathtt{t\_token?}(i) = \begin{cases}
   t_i = t_{i-1} & i = 0
\\ t_i \ne t_{i-1} & i \ne 0
\end{cases}$
\end{centering}
}
Note: $\unique i\in\Nat_n: \phi(i)$ means that there exists exactly one $i$ for which the predicate $\phi(i)$ is satisfied.
\newpage
\section{Experiments}
%* Experiments: Clearly and in detail describe the experimental setup. Use a "storyboard" like approach if possible. Give all the information so that
% someone who reads the report can replicate your experiments. Explain and discuss the experimental results. How were the problems selected? Did you
% use problems with varying complexity and test the boundaries of the system?
For all of the following experiments, results were gather for an increasing number of processes until the runtime crossed a threshold of 5 minutes.
Timing was gathered using the "time" command in bash.  The number of states is given as a reference from knowledge of the problem, not as an
experimental result.
\begin{center}
2-coloring \\
\begin{tabular}{|c|c|c|c|c|}
\hline
 Processes & Time (sec) & Solution Size & Backtrack Depth & States \\
\hline
 2 & .009 & 2 & 2 & $2^{2}$             \\
 4 & .01 & 6 & 6 & $2^{4}$              \\
 6 & .015 & 10 & 10 & $2^{6}$           \\
 8 & .047 & 14 & 14 & $2^{8}$           \\
 10 & .15 & 18 & 18 & $2^{10}$          \\
 12 & .486 & 22 & 22 & $2^{12}$         \\
 14 & 1.346 & 26 & 26 & $2^{14}$        \\
 16 & 3.595 & 30 & 30 & $2^{16}$        \\
 18 & 10.547 & 34 & 34 & $2^{18}$       \\
 20 & 34.282 & 38 & 38 & $2^{20}$       \\
\hline
\end{tabular}
\end{center}

The 2-coloring experiment was run for even numbered processes on the range of [2..20].  This domain was chosen because an even number of processes
cannot stabilize in a 2-coloring problem.  This is a fairly uncomplicated problem, so the results aren't all that unusual.  The solution size and depth
increase linearly at a rate of 4.  The timing increases roughly linearly at a rate of 3 when the number of processes is 6 and greater.  This serves
mostly as a baseline problem for the stabilizer.

\begin{center}
3-coloring \\
\begin{tabular}{|c|c|c|c|c|}
\hline
 Processes & Time (sec) & Solution Size & Backtrack Depth & States \\
\hline
 2 & .003 & 3 & 3 & $3^{2}$           \\
 3 & .039 & 21 & 21 & $3^{3}$         \\
 4 & .105 & 30 & 30 & $3^{4}$          \\
 5 & .63 & 33 & 32 & $3^{5}$          \\
 6 & 1.728 & 39 & 38 & $3^{6}$        \\
 7 & 7.726 & 45 & 44 & $3^{7}$        \\
 8 & 15.887 & 51 & 50 & $3^{8}$       \\
 9 & 74.22 & 59 & 58 & $3^{9}$        \\
 10 & 134.946 & 65 & 64 & $3^{10}$    \\
\hline
\end{tabular}
\end{center}

The 3-coloring problem turned out to be a bit more interesting.  It was run for processes numbering [2..10].  The rates of increase area all variable
for this experiment.  For the lower processor numbers, timing saw increases of up to 10 times, and the solution size and backtrack depths saw increases
of up to 7 times.  You can also see that the solution size and backtrack depth differ in this problem.  This means that the algorithm was able to infer
an action during forward checking, without actually exploring it.  This prevents the program from having to explore more paths, reducing the overall
runtime.  The increases in runtime also correlate roughly with the increases in solution size and backtrack depth.  Since there is not a whole lot
of backtracking that needs to be done for a 3-coloring problem, this makes sense.  If there is the increase in runtime is disproportionate to the
increases in solution size and backtrack depth, it most likely means that backtracking had to occur, causing more work for a smaller or less deep
solution.

\newpage

\begin{center}
Sum Not 2 \\
\begin{tabular}{|c|c|c|c|c|}
\hline
 Processes & Time (sec) & Solution Size & Backtrack Depth & States \\
\hline
 2 & .002 & 3 & 3 & $3^{2}$               \\
 3 & .006 & 9 & 9 & $3^{3}$               \\
 4 & .014 & 12 & 12 & $3^{4}$             \\
 5 & .047 & 15 & 15 & $3^{5}$             \\
 6 & .15 & 18 & 18 & $3^{6}$              \\
 7 & .361 & 21 & 21 & $3^{7}$              \\
 8 & .743 & 24 & 24 & $3^{8}$             \\
 9 & 1.381 & 27 & 27 & $3^{9}$            \\
 10 & 2.463 & 30 & 30 & $3^{10}$          \\
 11 & 4.292 & 33 & 33 & $3^{11}$          \\
 12 & 7.098 & 36 & 36 & $3^{12}$          \\
 13 & 11.79 & 39 & 39 & $3^{13}$          \\
 14 & 19.002 & 42 & 42 & $3^{14}$         \\
 15 & 30.676 & 45 & 45 & $3^{15}$         \\
 16 & 49.034 & 48 & 48 & $3^{16}$         \\
 17 & 72.74 & 51 & 51 & $3^{17}$          \\
 18 & 106.68 & 54 & 54 & $3^{18}$          \\
 19 & 152.64 & 57 & 57 & $3^{19}$         \\
 20 & 210.548 & 60 & 60 & $3^{20}$        \\
\hline
\end{tabular}
\end{center}

The Sum Not 2 problem was able to complete in under 5 minutes for up to 20 processes.  It shows 2 linear
increases in the solution size and backtrack depth: 6 for less than 4 processes, and 3 for greater than
4.  This probably happens because the pruning algorithm, together with forward checking, does a great job
of choosing the correct path and pruning the incorrect ones.  The change rate for runtimes exhibits a 
decreasing trend as the processes increase.  For example, from 2 to 3 the rate is 2, from 19 to 20 the
rate is .379.  The explanation for this is most likely pretty mundane, such as the effects of some
computational overhead diminishing as more work is being done, but it shows that our algorithm is
executing in better than exponential time.   
 
\begin{center}
Dijsktra's Token Ring-Highest Processor Number Heuristic \\
\begin{tabular}{|c|c|c|c|c|}
\hline
 Processes & Time (sec) & Solution Size & Backtrack Depth & States \\
\hline
 3 & .023 & 28 & 8 & $4^{3}$         \\
 4 & 7.165 & 65 & 13 & $5^{4}$          \\
 5 & 1390.109 & 126 & 20 & $6^{5}$    \\
\hline
\end{tabular}
\end{center}

The heuristic used for this experiment is to have the algorithm choose actions from the processes with
the highest number first, essentially forcing a counter-clockwise movement around the ring.  The first
thing to notice about the Dijkstra's Ring experiments is that the final results are more than 5 minutes.
We included these results to allow us to draw some limited conclusions about the data, which couldn't
really be done with the this version of the token ring under the 5 minute restriction.  It should also be
noted that Dijkstra's Ring is the only problem for which the algorithm actually backtracks and when the
ordering is imposed, it backtracks more than one level.  It's impossible to assume the complexity with
which the algorith runs this experiment with any kind of certainty, but it is easy to see that the rates
of change from one step to the next is huge.  The runtime for 3 processes is only .3\% of the runtime
for 4 processes, which in turn is only .5\% of the runtime for 5.  This is probably due to the
backtracking, which can cause the algorithm to take a very long time, and can be very wasteful because
of all the prior work backtracking has to discard.

\newpage

\begin{center}
Dijsktra's Token Ring-No Ordering Imposed \\
\begin{tabular}{|c|c|c|c|c|}
\hline
 Processes & Time (sec) & Solution Size & Backtrack Depth & States \\
\hline
 3 & .02 & 28 & 8 & $4^{3}$         \\
 4 & .595 & 65 & 14 & $5^{4}$          \\
 5 & 10.249 & 126 & 22 & $6^{5}$        \\
 6 & 194.014 & 217 & 32 & $7^{6}$      \\
 7 & 2450.748 & 344 & 44 & $8^{7}$    \\
\hline
\end{tabular}
\end{center}

This experiment is the same problem as the last one, but without imposing the counter-clockwise ordering.
The solution sizes and backtrack depths are similar to what they were in the previous experiment, but 
the runtimes are noticeably smaller.  At 3 processes it stays about the same, but for 4 processes these
results are 8.3\% of the old results, and for 5 processes these are .7\% of the old results.  For each
number of processes, the runtime is roughly 20 times as large as the runtime using 1 less processor.
Over the observed intervals, the algorithm clearly handles Dijkstra's Token Ring better without a 
counter clockwise ordering.

\begin{center}
2-bit Token Spring \\
\begin{tabular}{|c|c|c|c|c|}
\hline
 Processes & Time (sec) & Solution Size & Backtrack Depth & States \\
\hline         
 2 & .01 & 14 & 9 & $4^{2}$         \\
 3 & .055 & 21 & 13 & $4^{3}$       \\
 4 & 1.019 & 26 & 13 & $4^{4}$      \\
 5 & 5.402 & 31 & 13 & $4^{5}$      \\
 6 & 17.789 & 37 & 14 & $4^{6}$     \\
 7 & 48.017 & 43 & 15 & $4^{7}$     \\
 8 & 113.130 & 49 & 16 & $4^{8}$    \\
 9 & 250.614 & 55 & 17 & $4^{9}$    \\
\hline
\end{tabular}
\end{center}

The interesting thing about the 2-bit Token Spring results is that there aren't many really good patterns
in the data.  The rate of change for the runtimes trends downwards again as the processes increase, but
the increases for the solution size stick around a 5-7 range, but jump around a lot in that range, and
the increases for the backtrack depth change from 4 to 0 then back to 1.  We can conclude that the
algorithm isn't increasing exponentially, but we can't really conclude much more than that.

\begin{center}
3-bit Token Ring \\
\begin{tabular}{|c|c|c|c|c|}
\hline
 Processes & Time (sec) & Solution Size & Backtrack Depth & States \\
\hline         
 3 & .631 & 53 & 52 & $8^{3}$       \\
 4 & 5.862 & 70 & 68 & $8^{4}$      \\
 5 & 64.304 & 97 & 95 & $8^{5}$      \\
\hline
\end{tabular}
\end{center}

The 3-bit Token Ring was another problem that we couldn't run with very many processes.  The the runtime
for 3 processes is about 10\% of the rate for processor for, and the rate for 4 processor is about 9\%
of the rate for 5 processes.  If we extrapolate, which can't be done with much confidence, 6 processes
would stabilize in roughly 13.5 minutes.  So the rate appears to decrease, but only by a little, and
the rate starts so high that it doesn't make much of a difference.

\begin{center}
Matching-Light Greedy Heuristic \\
\begin{tabular}{|c|c|c|c|c|}
\hline
 Processes & Time (sec) & Solution Size & Backtrack Depth & States \\
\hline         
 2 & .047 & 7 & 6 & $3^{2}$        \\
 3 & .062 & 24 & 24 & $3^{3}$       \\
 4 & .594 & 38 & 35 & $3^{4}$      \\
 5 & 1.167 & 45 & 41 & $3^{5}$      \\
 6 & 6.811 & 61 & 52 & $3^{6}$     \\
 7 & 16.042 & 69 & 60 & $3^{7}$    \\
 8 & 53.214 & 75 & 66 & $3^{8}$    \\
\hline
\end{tabular}
\end{center}

\begin{center}
Matching-Heavy Greedy Heuristic \\
\begin{tabular}{|c|c|c|c|c|}
\hline
 Processes & Time (sec) & Solution Size & Backtrack Depth & States \\
\hline         
 2 & .006 & 7 & 6 & $3^{2}$        \\
 3 & .105 & 24 & 24 & $3^{3}$       \\
 4 & .69 & 36 & 34 & $3^{4}$      \\
 5 & 2.291 & 46 & 40 & $3^{5}$      \\
 6 & 6.444 & 60 & 52 & $3^{6}$     \\
 7 & 17.944 & 61 & 59 & $3^{7}$    \\
 8 & 64.787 & 73 & 65 & $3^{8}$    \\
\hline
\end{tabular}
\end{center}

The final problem we examined was the maximal matching problem.  We compared 2 forms of greedy heuristic:
one which uses a more precise method for determining how much influence each action has, and one that
accepts a little innaccuracy in finding the most influential action.  Note that a clockwise ordering is
imposed, because the algorithm begins backtracking with 6 or more processes otherwise.  The effect of the
heuristics is that the first heuristic should be faster, but the second one should choose better
actions, reducing the solution size and backtrack depth.  The first heuristic appears to shave some time
off of the running time for more than 2 processes, but the decrease is not much in the range we were able
to collect.  You do begin to see the first heuristic gaining noticeable improvement with 8 process, but
the second heuristic should, in theory, improve later on as the effects of it's better action choices
become more apparent.

\section{Instructions to Run Code}
%* Full commented code with instructions to run it as is and with different parameters.
\subsection{Running the code}
The program could be executed in terminal using the following command:

\begin{center}
\texttt{./bin/protocon [-model file.pml] <problem> <numprocs>}
\end{center}

\texttt{<problem>} is the problem instance, it can be one of:
"3-coloring", "2-coloring", "matching", "sum-not-2", "dijkstra-tr", "3-bit-tr", "2-bit-tr"

\texttt{<numprocs>} is number of processes.

Use the \texttt{-model} flag if a Promela model of the synthesized protocol is desired.
This model can be checked by the SPIN model checker.

\subsection{Outputs}
In the output, there are two sections. The first section shows the type of ring and the steps the program took. And the second section is a summery of the actions each process has taken.

In the first secion,

\texttt{(lvl n)} means that the output is generated at the level $n$ of recursion. At least $n$ actions will be chosen at this point.

\texttt{(sz n)} means that there are actually $n$ actions chosen. It can be larger than the recursion level if the actions are included based on forward-checking.

\texttt{(rem n)} means that there are $n$ remaining candidate actions at this point. The part printed after is the action being chosen, which is indicated in $\textbf{\emph{(sz\ m)}}$ before. 

\texttt{(lvl x) (mcv y) (mcv-sz z)} is printed when making the decision to pick the next action (applying the MCV heuristic). This one is at level $x$, where the most constrained deadlock(s) have only $y$ different candidate actions that resolve them, but there are many sets of deadlocks which may only be resolved by $y$ different candidate actions. In total, $z$ candidate actions can resolve one of these most-constrained deadlocks.

In the second section, the success or failure of finding a solution will be shown first. If the solution is successfully found. It is going to be represented in a series of actions listed in the order of process indices. The actions are presented in the form: 
\begin{center}
\texttt{process: state before action -> action executed}
\end{center}
where ``state before action'' are only the states that trigger the following action. 

\section{Task Distribution}
%* How were the tasks distributed among the group members? How long did it take for tasks to complete?

\begin{center}
\begin{tabular}{|c||c|c|c|}
\hline
 Task & Estimate & People & Status \\
\hline
 BDD & 1 week, 2 people & all & done \\
 Topology & 1 week, 3 people & all & done \\
 Input File & 3 days, 3 people & all & N/A \\
 Weak Stabilization Check & 2 days, 1 person & Mandy & done \\
 Cycle Check & 1 week, 1 person & Alex & done \\
 Backtracking Algorithm & 4 days, 2 people & Brandon \& Mandy & done \\
 Output File & 1 day, 1 person &  Brandon & N/A \\
 Output Model & 1 day, 1 person & Alex & done \\
 Forward Checking & 2 days, 3 people & all & done \\
 Most-Constrained Variable & 1 week, 3 people & all & done \\
 AC-3 & 1 week, 3 people & all & done, removed \\
 Examples and Comparison & 2 weeks, 3 people & all & done \\
\hline
\end{tabular}
\end{center}

\section{Contributions and Accomplishments}
%* Contributions and accomplishments. Were you able to accomplish the minimal set of goals identified in your proposal? What else was accomplished? Make sure to define accomplishments specifically, supplementing phrases such as "better" or "improved" by numeric data.

This work gives some insight on why polynomial-time heuristic methods such as \cite{ipdpsEbnenasir11} succeed for the examples we showed.
We were able to avoid backtracking in many cases by simply choosing actions in the proper order, combined with forward-checking.

Our approach is especially useful because it is a complete search.
In the case our search algorithm fails, we know there is no solution.

\section{Lessons Learned}

We learned that it is simple to collaborate on code and documentation in version control.

We also learned that this problem does not lend itself well to the AC-3 heuristic.
Actions are far too interrelated, so we could not find an effective scheme resembling AC-3 which pruned more candidate actions than our forward checking.

\section{Future Work}

An interesting addition to this would be to impose symmetry between certain processes, meaning they all have the same actions (modulo variable names).
This is practically interesting and would lower the worst-case backtracking depth since adding more symmetric processes would not increase the solution size.

\section{Project Comments and Suggestions}
%* Any comments and suggestions of the project component of CS5811 will be appreciated.



%{\it Formulate the search problem: states, actions, goals.}


\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}

