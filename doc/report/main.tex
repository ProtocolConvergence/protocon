
\input{preamble}

\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\setlength{\abovedisplayskip}{0.5em}
\setlength{\abovedisplayshortskip}{0.5em}
\setlength{\belowdisplayskip}{0.5em}
\setlength{\belowdisplayshortskip}{0.5em}
\setlength{\abovecaptionskip}{0.0em}
\setlength{\belowcaptionskip}{0.0em}

\begin{document}
\title{
 CS5811 Report:\\
 Search for Self-Stabilizing Protocols
}

\author{~Brandon~Crowley\and~Alex~Klinkhamer\and~Man~Wang}
\maketitle

\tableofcontents

\section{Project Description}

\subsection{Problem}

Given a network of processes (finite-state machines) and an invariant $I$ over their variables, find a set of actions for the processes which guarantees every computation from any initial global state will eventually reach the invariant.

%The problem of finding a self-stabilizing protocol is a search

For each process $P_i$, network topology defines the variables which $P_i$ owns and which other variables $P_i$ can read.
A process can read and write its own variables and may only read the variables of other processes.
The purpose of a process is to act.
A process can have actions of the form $\mathit{guard} \to \mathit{assignment}$ where $\mathit{guard}$ is a predicate over the readable variables of $P_i$ and $\mathit{assignment}$ is a variable assignment.
\begin{enumerate}
\item If $P_i$ sees a guard is satisfied, it performs the appropriate variable assignment.
 \begin{enumerate}
 \item Note that another process may reassign its variable before $P_i$ can act!
 \end{enumerate}
\item The read/write cycle of an action happens atomically. This is interleaving semantics and we can assume that at most one read/write cycle of an action is happening at any given time.
\item If a process does not have a guard which is satisfied, it does not act.
\item If no two guards can be satisfied at the same time, the process is deterministic.
\end{enumerate}

We can represent actions in the finest possible granularity by considering only local transitions.
For example, if process $P_1$ can read $x_0$ and $x_1$, each spanning $\aset{0,1,2}$, and write $x_1$, then an action 
\[ x_1 = 0 \wedge x_0 = 2 \to x_1 \defeq 1; \]
is a local transition from $(x_1 = 0 \wedge x_0 = 2)$ to $(x_1 = 1 \wedge x_0 = 2)$.
We would not consider an action such as
\[ x_1 = 0 \to x_1 \defeq 1; \]
for $P_1$ because it represents $3$ local transitions:
from $(x_1 = 0 \wedge x_0 = 0)$ to $(x_1 = 1 \wedge x_0 = 0)$,
from $(x_1 = 0 \wedge x_0 = 1)$ to $(x_1 = 1 \wedge x_0 = 1)$,
and from $(x_1 = 0 \wedge x_0 = 2)$ to $(x_1 = 1 \wedge x_0 = 2)$.

\subsection{Problem as a Graph}

We can think of a graph where each vertex corresponds with a global state in the system.
An action is represented by several arcs, each with the same label.
Next mark all global states which satisfy the invariant.

The problem of adding convergence to a system (finding a self-stabilizing protocol) is the same as finding a set of labels for which the set of all arcs with those labels:
\begin{enumerate}
\item Does not include arcs from a vertex marked as invariant to a vertex not marked as invariant.
 \begin{enumerate}
 \item Closure.
 \end{enumerate}
\item Form a path from each vertex not marked as invariant to a vertex marked as invariant.
 \begin{enumerate}
 \item Weak-convergence.
 \end{enumerate}
\item Does not form cycles among the vertices not marked as invariant.
 \begin{enumerate}
 \item Livelock freedom.
 \end{enumerate}
\end{enumerate}

Sometimes no arcs are allowed from any invariant states.

\subsection{Example: Sum-Not-2}

Consider the Sum-Not-2 problem on $3$ processes.
Each process $P_i$ owns a variable $x_i\in\Nat_3$ (where $\Nat_3 = \aset{0,1,2}$).
Processes are in a unidirectional ring meaning each $P_i$ can read its anticlockwise neighbor $P_{i-1}$ (subtraction is modulo $3$).
The invariant is all states where no $x_i + x_{i-1} = 2$, so $I \equiv (\forall i\in\Nat_3: x_i + x_{i-1} \ne 2)$.

Illustrated in the three figures are the problem instance, a stabilizing protocol, and how that protocol appears as a transition graph over the global state space.
\begin{figure}[h]
\begin{tabular}{lc}
\begin{tabular}[b]{@{}l@{}}
For all $i\in\Nat_3$, $P_i$ has privileges:
\\
\begin{centering}
$P_i :
\begin{cases}
 x_i\in\Nat_3 & \mbox{(read-write)} \\
 x_{i-1}\in\Nat_3 & \mbox{(read-only)} \\
\end{cases}$
\end{centering}
\\
Invariant:
$I \equiv (\forall i\in\Nat_3: x_i + x_{i-1} \ne 2)$
\end{tabular}
&
\begin{tikzpicture}[x=1.5cm,y=1.5cm]
\tikzstyle{every node}=[draw,circle]
\draw
 (0,0)      node (0) {$P_0$}
 ++( -60:1) node (1) {$P_1$}
 ++(-180:1) node (2) {$P_2$}
 ;
\path[->,draw,thick]
(0) edge (1)
(1) edge (2)
(2) edge (0)
;
\end{tikzpicture}
\\
\end{tabular}
\caption{Sum-Not-2 problem instance.}
\end{figure}

\begin{figure}[h]
\begin{eqnarray*}
   (x_i = 0) \wedge (x_{i-1} = 2) & \to & x_i \defeq 1;
\\ (x_i = 1) \wedge (x_{i-1} = 1) & \to & x_i \defeq 0;
\\ (x_i = 2) \wedge (x_{i-1} = 0) & \to & x_i \defeq 0;
\end{eqnarray*}
\caption{Actions of each $P_i$ in a stabilizing protocol for Sum-Not-2.}
\end{figure}

\begin{figure}[h]
\centering
\begin{tikzpicture}[x=1.0cm,y=1.0cm]
\tikzstyle{every node}=[]
\tikzstyle{legit}=[draw]
\def \dx {3.5}
\draw
  (  0, 0) node [legit] (000) {000}
++(\dx, 0) node [legit] (100) {100}
++(\dx, 0) node         (200) {200}
  (  0,-1) node [legit] (010) {010}
++(\dx, 0) node         (110) {110}
++(\dx, 0) node         (210) {210}
  (  0,-2) node         (020) {020}
++(\dx, 0) node         (120) {120}
++(\dx, 0) node         (220) {220}
  (  1, 0) node [legit] (001) {001}
++(\dx, 0) node         (101) {101}
++(\dx, 0) node         (201) {201}
  (  1,-1) node         (011) {011}
++(\dx, 0) node         (111) {111}
++(\dx, 0) node         (211) {211}
  (  1,-2) node         (021) {021}
++(\dx, 0) node         (121) {121}
++(\dx, 0) node [legit] (221) {221}
  (  2, 0) node         (002) {002}
++(\dx, 0) node         (102) {102}
++(\dx, 0) node         (202) {202}
  (  2,-1) node         (012) {012}
++(\dx, 0) node         (112) {112}
++(\dx, 0) node [legit] (212) {212}
  (  2,-2) node         (022) {022}
++(\dx, 0) node [legit] (122) {122}
++(\dx, 0) node [legit] (222) {222}
;
\path[->,draw,thick]
(002) edge [color=red!40,out=- 20,in= 200,looseness=.7] (102)
(012) edge [color=red!40,out=- 20,in= 200,looseness=.7] (112)
(022) edge [color=red!40,out=- 20,in= 200,looseness=.7] (122)
(101) edge [color=red!40,out= 140,in=  30,looseness=.6] (001)
(111) edge [color=red!40,out= 140,in=  30,looseness=.6] (011)
(121) edge [color=red!40,out= 140,in=  30,looseness=.6] (021)
(200) edge [color=red!40,out= 160,in=  70,looseness=.3] (000)
(210) edge [color=red!40,out= 160,in=  70,looseness=.3] (010)
(220) edge [color=red!40,out= 160,in=  70,looseness=.3] (020)

(200) edge [color=green!50!black!75,out=-120,in= 120] (210)
(201) edge [color=green!50!black!75,out=-120,in= 120] (211)
(202) edge [color=green!50!black!75,out=-120,in= 120] (212)
(110) edge [color=green!50!black!75,out=  50,in=- 50] (100)
(111) edge [color=green!50!black!75,out=  50,in=- 50] (101)
(112) edge [color=green!50!black!75,out=  50,in=- 50] (102)
(020) edge [color=green!50!black!75,out= 140,in=-140,looseness=.5] (000)
(021) edge [color=green!50!black!75,out= 130,in=-130,looseness=.5] (001)
(022) edge [color=green!50!black!75,out= 130,in=-130,looseness=.5] (002)

(002) edge [color=blue,out= 120,in=  40,looseness=.5] (000)
(102) edge [color=blue,out= 120,in=  40,looseness=.5] (100)
(202) edge [color=blue,out= 120,in=  40,looseness=.5] (200)
(011) edge [color=blue,out= 130,in=  60] (010)
(111) edge [color=blue,out= 130,in=  60] (110)
(211) edge [color=blue,out= 130,in=  60] (210)
(020) edge [color=blue,out=- 60,in= 230] (021)
(120) edge [color=blue,out=- 60,in= 230] (121)
(220) edge [color=blue,out=- 60,in= 230] (221)
;
\end{tikzpicture}
\caption{Transitions of {\color{red!40} $P_0$}, {\color{green!50!black!75} $P_1$}, {\color{blue} $P_2$}. Legitimate states $x_0x_1x_2$ are boxed.}
\end{figure}

%* A description of the project and its goals. How does it relate to Artificial Intelligence.

\section{Background}
%* Background: related literature and software and algorithms that you imported into your project. Clearly describe, work that you directly used, work you used after modification, and your own contribution.

%* Comparison to similar projects

\section{Experiments}
%* Experiments: Clearly and in detail describe the experimental setup. Use a "storyboard" like approach if possible. Give all the information so that someone who reads the report can replicate your experiments. Explain and discuss the experimental results. How were the problems selected? Did you use problems with varying complexity and test the boundaries of the system?

\section{Task Distribution}
%* How were the tasks distributed among the group members? How long did it take for tasks to complete?

\begin{center}
\begin{tabular}{|c||c|c|c|}
\hline
 Task & Estimate & People & Status \\
\hline
 BDD & 1 week, 2 people & all & done \\
 Topology & 1 week, 3 people & all & done \\
 Input File & 3 days, 3 people & all & N/A \\
 Weak Stabilization Check & 2 days, 1 person & Mandy & done \\
 Cycle Check & 1 week, 1 person & Alex & done \\
 Backtracking Algorithm & 4 days, 2 people & Brandon \& Mandy & done \\
 Output File & 1 day, 1 person &  Brandon & N/A \\
 Output Model & 1 day, 1 person & Alex & done \\
 Forward Checking & 2 days, 3 people & all & done \\
 Most-Constrained Variable & 1 week, 3 people & all & done \\
 AC-3 & 1 week, 3 people & all & done, removed \\
 Examples and Comparison & 2 weeks, 3 people & all & done \\
\hline
\end{tabular}
\end{center}

\section{Contributions and Accomplishments}
%* Contributions and accomplishments. Were you able to accomplish the minimal set of goals identified in your proposal? What else was accomplished? Make sure to define accomplishments specifically, supplementing phrases such as "better" or "improved" by numeric data.

This work gives some insight on why polynomial-time heuristic methods such as \cite{ipdpsEbnenasir11} succeed.
We were able to avoid backtracking in many cases by simply choosing actions in the proper order, combined with forward-checking.

\section{Lessons Learned}

We learned that it is simple to collaborate on code and documentation in version control.

\section{Future Work}

This work gives some insight on why polynomial-time heuristic methods such as \cite{ipdpsEbnenasir11} succeed.
We were able to avoid backtracking in many cases by simply choosing actions in the proper order, combined with forward-checking.

\section{Instructions to Run Code}
%* Full commented code with instructions to run it as is and with different parameters.

\section{Project Comments and Suggestions}
%* Any comments and suggestions of the project component of CS5811 will be appreciated.



%{\it Formulate the search problem: states, actions, goals.}


\section{BDD Algorithms}
As in regular software or any search algorithm, the states could be of large amount and rather complex. Simply listing the states is inefficient and complicates analysis. Here we resort to Multiple-Valued Logic for describing the state of a system, represented by a multiple-valued decision diagram (MDD), which is general version of BDD. This allows countermeasures to be formated that address states that share common features. 

Both BDDs and MDDs provide a uniform way to represent formulas which evaluate to {\it true} or {\it false} based on variable values (i.e., predicate functions).
We use them because they can also use {\em much less} space than a truth-table.
BDDs and MDDs differ only by the domains of variables. BDDs only allows boolean variables, so they can express the input formulas of the satisfiability problem.
MDDs, on the other hand, allow variables to have finite domains (conventionally represented by natural numbers starting at $0$).
As any integer can be represented by string of bits, MDDs can be implemented using BDDs.

Consider a predicate over three variables $x, y, z$, each with values ranging from $0$ to $4$ (domain size 3). Initially, there are $5^3 = 125$ states in the system. If we specify the state predicate as $x=3$, the number of states for which the predicate returns {\it true} is $25$, since the value of $x$ is totally fixed. We could use an MDD to symbolically represent this set of $25$ states.

Now we have a rough format close to the format representing the protocol states later on. Say there are 3 processes arranged in the bidirectional ring, and each node could read from its two neighbors and write to itself. Actually, with three processes in a bidirectional ring, each process can read all variables, but the small state-space is convenient for this example. We use $m_0$ as the variable of $P_0$. $m'_0$ means the same except the value is the one in the next time step. Similarly, this rule applies to processes $P_1$ and $P_2$. The following predicate represents a transition function for this system:
\begin{eqnarray*}
 & & m_0 = 0 \wedge m'_0 = 0 \wedge m_1 = 0 \wedge m'_1 = 1 \wedge m_2 = 1 \wedge m'_2 = 1 \\
 & \vee & m_0 = 0 \wedge m'_0 = 0 \wedge m_1 = 2 \wedge m'_1 = 1 \wedge m_2 = 1 \wedge m'_2 = 1
\end{eqnarray*}
After checking the values of each process, it is obvious that there are some variables which will change their values as time goes on. The value of $m_1$ can change to $1$ from $0$ when $m_0 = 0 \wedge m_1 = 0 \wedge m_2 = 1$. The value of $m_1$ can also change to $1$ from $2$ when $m_0 = 0 \wedge m_1 = 2 \wedge m_2$. This shows how to represent a transition function with satisfying valuations of unprimed and primed variables.

%In another aspect, a formula could be created as the evaluation standard for judging whether a state is a legitimate state or not. Still in the above instance, if $(m_0={m'}_0)\cap (m_2={m'}_2)\cap (m_0=0)\cap (m_2=1)\cap (m_1=0\cup m_1=2)\cap ({m'}_1=1)$ is the standard for telling whether the questioned state is an illegitimate state, then the two states above are illegitimate states since the output from the standard is true. Therefore, an action is required, which could be ${m'}_1=1$, to transfer the state into legitimate state region, and therefore stabilize the system.

\section{Examples}
Some examples of stabilizing protocols follow.
We plan to use these (and more) in our experimentation.

We should also try to use reduction to SAT on these problems, but encoding cycle detection in a CNF formula blows up quickly in size.
In the worst case, we require $O(\abs{S_p}^3)$ where $S_p$ is set of all states.
Our tool should outperform the reduction to SAT purely due to its exploding size.

\subsection{Dijkstra's Token Ring}
Let us consider the original token ring protocol Dijkstra used when introducing the concept of self-stabilization \cite{dij}.
A token ring is used to give one process out of many an exclusive right, also known as distributed mutual exclusion.
Below is a ring of $n=6$ finite-state machines (processes).

\begin{tikzpicture}[x=1.5cm,y=1.5cm]
 \tikzstyle{every node}=[draw,circle]
 \draw
 (0,0)      node (0) {$P_0$}
 ++(   0:1) node (1) {$P_1$}
 ++( -60:1) node (2) {$P_2$}
 ++(-120:1) node (3) {$P_3$}
 ++(-180:1) node (4) {$P_4$}
 ++(-240:1) node (5) {$P_5$}
 ;
 \draw (0) -- (1);
 \draw (1) -- (2);
 \draw (2) -- (3);
 \draw (3) -- (4);
 \draw (4) -- (5);
 \draw (5) -- (0);
\end{tikzpicture}

Each process $P_i$ holds a variable $x_i$ which ranges from $0$ to $n$ ($x_i\in\Nat_{n+1}$).
Each $P_i$ can read and write $x_i$ and can read $x_{i-1}$ (where subtraction is modulo $n$).
Note that each process can only read its left neighbor, so we call this ring {\em unidirectional}.

$P_0$ is said to have a token when it sees $x_{n-1} = x_0$.
Any other $P_i$ has a token when $x_{i-1} \neq x_i$.

A state is legitimate when exactly one process has the token.

\[
\begin{array}{rrcl}
 P_0: & x_{5} = x_0 & \to & x_0 \defeq x_0 + 1 \mod (n+1)
\\ P_{i>0}: & x_{i-1} \neq x_i & \to & x_i \defeq x_{i-1}
\end{array}
\]

\subsection{Maximal Matching}

Let each process $P_i$ in a bidirectional ring of $n$ processes have a variable $m_i\in \Nat_3$ (i.e., $m_i\in \{0,1,2\}$) where each of the three values represents a different direction, like {\it self} ($m_i=0$), {\it left} ($m_i=1$), and {\it right} ($m_i=2$).
Since this is a bidirectional ring, any $P_i$ can read its left and right neighbors' variables $m_{i-1}$ and $m_{i+1}$.
$P_i$ can also read and write its own variable $m_i$.

The system is in a legitimate state when neighbors pair up by pointing at each other.
If both neighbors are pointing away, a process can point at itself.
Formally, the invariant is defined as (with arithmetic modulo $n$):
\begin{eqnarray*}
 I \equiv \forall i\in\Nat_n: & & (m_{i-1} = 2 \wedge m_i = 1)
                    \\ & \vee  & (m_{i-1} = 1 \wedge m_i = 0 \wedge m_{i+1} = 2)
                    \\ & \vee  & (m_i = 2 \wedge m_{i+1} = 1)
\end{eqnarray*}

\subsection{3-Coloring on a Ring}

Let each process $P_i$ in a bidirectional ring of $n$ processes have a variable $c_i\in \Nat_3$ (i.e., $c_i\in \{0,1,2\}$) where each of the three values represents a different color, like {\it red}, {\it green}, and {\it blue}.
Since this is a bidirectional ring, any $P_i$ can read its left and right neighbors' variables $c_{i-1}$ and $c_{i+1}$.
$P_i$ can also read and write its own variable $c_i$.

The system is in a legitimate state when no two neighboring processes have the same color.
Formally, the invariant is defined as (with arithmetic modulo $n$):
\[ I \equiv (\forall i\in\Nat_n: c_{i-1}\ne c_i \wedge c_i \ne c_{i+1}) \]

The following action for each $P_i$ can be used for a stabilizing protocol:
\[
 (c_{i-1} = c_i) \vee (c_i = c_{i+1}) \to c_i \defeq \textsc{Other}(c_{i-1}, c_{i+1})
\]
where the \textsc{Other} function returns a color (deterministically, say the minimal-valued one) which is not equal to either of its inputs.

We expect our tool to synthesize actions in their most basic form, as local state transitions.
The above action can be expressed by the following $15$ local state transitions for $P_i$:
\begin{eqnarray*}
 c_{i-1} = 0 \wedge c_i = 0 \wedge c_{i+1} = 0 & \to & c_i \defeq 1 \\
 c_{i-1} = 0 \wedge c_i = 0 \wedge c_{i+1} = 1 & \to & c_i \defeq 2 \\
 c_{i-1} = 1 \wedge c_i = 0 \wedge c_{i+1} = 0 & \to & c_i \defeq 2 \\
 c_{i-1} = 2 \wedge c_i = 0 \wedge c_{i+1} = 0 & \to & c_i \defeq 1 \\
 c_{i-1} = 0 \wedge c_i = 0 \wedge c_{i+1} = 2 & \to & c_i \defeq 1 \\
 c_{i-1} = 1 \wedge c_i = 1 \wedge c_{i+1} = 1 & \to & c_i \defeq 0 \\
 c_{i-1} = 1 \wedge c_i = 1 \wedge c_{i+1} = 0 & \to & c_i \defeq 2 \\
 c_{i-1} = 0 \wedge c_i = 1 \wedge c_{i+1} = 1 & \to & c_i \defeq 2 \\
 c_{i-1} = 1 \wedge c_i = 1 \wedge c_{i+1} = 2 & \to & c_i \defeq 0 \\
 c_{i-1} = 2 \wedge c_i = 1 \wedge c_{i+1} = 1 & \to & c_i \defeq 0 \\
 c_{i-1} = 2 \wedge c_i = 2 \wedge c_{i+1} = 2 & \to & c_i \defeq 0 \\
 c_{i-1} = 2 \wedge c_i = 2 \wedge c_{i+1} = 0 & \to & c_i \defeq 1 \\
 c_{i-1} = 0 \wedge c_i = 2 \wedge c_{i+1} = 2 & \to & c_i \defeq 1 \\
 c_{i-1} = 2 \wedge c_i = 2 \wedge c_{i+1} = 1 & \to & c_i \defeq 0 \\
 c_{i-1} = 1 \wedge c_i = 2 \wedge c_{i+1} = 2 & \to & c_i \defeq 0
\end{eqnarray*}


\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}

