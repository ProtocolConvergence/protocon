
%\documentclass{beamer}
\documentclass[handout]{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}

\input{predef}
\usepackage{listings}

\usepackage{tikz}
\usetikzlibrary{automata,arrows}

\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{bibliography item}[text]
\title{Search for Self-Stabilizing Protocols}
\author{Brandon Crowley \and Alex Klinkhamer \and Man Wang}
\institute{Michigan Technological University}
\date{2012}

\begin{document}

\setlength{\abovedisplayskip}{0.5em}
\setlength{\abovedisplayshortskip}{0.5em}
\setlength{\belowdisplayskip}{0.5em}
\setlength{\belowdisplayshortskip}{0.5em}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Representing State Sets}
\begin{itemize}
\item A state is a valuation of variables.
 \begin{itemize}
 \item In PDDL, these are predicates and functions on objects.
 \end{itemize}
\pause \item Can represent a set of states with a predicate formula.
 \begin{itemize}
 \item Ex: $x=1\vee y=0$ represents $3$ states of $2$ bits $x$ and $y$.
 \item Equivalently: $(x=0\wedge y=0) \vee (x=1\wedge y=0) \vee (x=1\wedge y=1)$.
 \end{itemize}
\item A predicate formula can be represented by...
 \begin{itemize}
 \pause \item Binary decision diagram (BDD) if all variables are Boolean.
 \pause \item Multi-valued decision diagram (MDD) if all variables are finite.
 \pause \item But what about infinite domains like $\Int$?
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Representing Transition Sets (Actions)}
\begin{itemize}
\item Introduce primed variables for destination variables.
\item Example:
 \begin{itemize}
 \item Consider an action $A$.
  \begin{itemize}
  \item[] Precondition: $y < 20$.
  \item[] Effect: $x \defeq x - y$.
  \end{itemize}
 \item As a formula: $A = (y < 20) \wedge (x' = x - y) \wedge (y' = y)$
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{State Set Operations}
\begin{itemize}
\item Formula conjunction.
\item Formula disjunction.
\item Formula negation.
\item Variable substitution by reordering bits of transition symbols.
 \begin{itemize}
 \item Change unprimed variables to primed.
 \item Change primed variables to unprimed.
 \end{itemize}
\item Existential quantification by MDD ``smoothing''.
\item Unique representation by MDD.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Image}
\begin{itemize}
\item The $\vbl{image}$ function finds all states which transitions $T$ map from $S$.
 \begin{itemize}
 \item $\vbl{image}(T,S) = \aset{s_1 \in \mathcal{S} \pipe\exists s_0\in S : (s_0,s_1)\in T}$
 \end{itemize}
\item Compute using standard operations.
 \begin{itemize}
 \item Conjunct the formulas of $S$ and $T$.
 \item Project out unprimed variables with existential quantification.
 \item Change primed variables to unprimed.
 \end{itemize}
\item Example:
 \begin{itemize}
 \item Let action $A = (y < 20) \wedge (x' = x - y) \wedge (y' = y)$.
 \item $\vbl{image}(A, (y > 3) \wedge (x = 2))$
 \\$= \vbl{unprime}(\exists x,y : (y > 3)\wedge (x = 2) \wedge A)$
 \\$= \vbl{unprime}((y' > 3) \wedge (y' < 20) \wedge (x' = 2 - y'))$
 \\$= (y > 3) \wedge (y < 20) \wedge (x = 2 - y)$
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Preimage}
\begin{itemize}
\item The $\vbl{preimage}$ function finds all states which are mapped to states in $S$ by transitions $T$.
 \begin{itemize}
 \item $\vbl{preimage}(T,S) = \aset{s_0 \in \mathcal{S} \pipe\exists s_1\in S : (s_0,s_1)\in T}$
 \end{itemize}
\item Compute using standard operations.
 \begin{itemize}
 \item Prime all variables in formula of $S$.
 \item Conjunct with formula of $T$.
 \item Project out primed variables with existential quantification.
 \end{itemize}
\item Example:
 \begin{itemize}
 \item Let action $A = (y < 20) \wedge (x' = x - y) \wedge (y' = y)$.
 \item $\vbl{preimage}(A, (y > 3) \wedge (x = 2))$
 \\$= \exists x',y' : \vbl{prime}((y > 3)\wedge (x = 2)) \wedge A$
 \\$= \exists x',y' : (y' > 3)\wedge (x' = 2) \wedge A$
 \\$= (y > 3) \wedge (y < 20) \wedge (x = y + 2)$
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Self-Stabilization}
\begin{itemize}
\item The $\vbl{invariant}$ is the set of states which are solutions to the problem.
\item The protocol is considered to be converging if it can transition to the invariant state
 \begin{itemize}
 \item A protocol is $\vbl{weakly}$ $\vbl{converging}$ if and only if, from every state outside the
    invariant, the invariant can be reached\cite{wssGouda01}.
 \item A protocol is $\vbl{strongly}$ $\vbl{converging}$ if and only if, from every state outside the
    invariant, the invariant must be reached.  This implies the protocol is livelock and deadlock
    free\cite{wssGouda01}.
 \end{itemize}
\item The goal of Self-Stabilization is to find an algorithm that can reach a legitimate state from
    any illegitimate state on it's own.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Example Protocol: 3-Coloring on a Ring}
\begin{itemize}
\item The goal of the protocol is the same as that of the traditional 3-Coloring problem: find a 
    coloring scheme in which no two consecutive processes have the same color.
\item Each process can see it's color, and the color of it's two neighbors.  It can only change it's
    own color.
\item For our representation, we use \{0,1,2\} to represent the three colors.
\item Invariant
 \begin{itemize}
 \item Given $c_i$ as the acting process, $c_{i-1}$ as the left neighbor, $c_{i+1}$ as the right
    neighbor, and I is the invariant state: 
    \[ I \equiv (\forall i\in\Nat_n: c_{i-1}\ne c_i \wedge c_i \ne c_{i+1}) \]
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Example Protocol: Maximal Matching}
\begin{itemize}
\item The goal of this protocol is to have every process be pointed to by either itself only, or it
    is pointing to a neighbor who is also pointing to it.
\item Again, each process can see where it is pointing, and where both of it's neighbors are
    pointing.
\item We use 0 to denote a process pointing to itself, 1 to denote pointing to its left neighbor
    and 2 to denote pointing to its right neighbor.
\item Invariant
 \begin{itemize}
 \item Given $m_i$ as the acting process, $m_{i-1}$ as the left neighbor, $m_{i+1}$ as the right
    neighbor, and I as the invariant:
  \begin{eqnarray*}
   I \equiv \forall i\in\Nat_n: & & (m_{i-1} = 2 \wedge m_i = 1)
                    \\ & \vee  & (m_{i-1} = 1 \wedge m_i = 0 \wedge m_{i+1} = 2)
                    \\ & \vee  & (m_i = 2 \wedge m_{i+1} = 1)
  \end{eqnarray*}
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A citation}
This is cool: \cite{sycraft2008}
\end{frame}

% Objective: do planning problem with infinite variable domains.
\begin{frame}[allowframebreaks]
\frametitle{References}
\bibliographystyle{abbrv}
\bibliography{bibliography.bib}
\end{frame}

\end{document}

