
constant N := 4;
constant M := N;

variable x[Nat % N] <- Nat % M;

process P[i <- Nat % N]
{
  write: x[i];
  write: x[i+1];

  // Only permit actions which swap x[i] and x[i+1] values.
  permit:
    ( 1==1 --> x[i]:=x[i+1]; x[i+1]:=x[i]; )
    ;

  puppet action:
    ( x[i+1]!=0 && x[i] > x[i+1] --> x[i]:=x[i+1]; x[i+1]:=x[i]; )
    ;
}

// Assumed initial states.
// Each x[i] is unique.
(assume & closed)
  (forall i <- Nat % N :
   (unique j <- Nat % N :
    x[i] == x[j]));

// Want to converge to a state where each next value in the
// ring is one greater than the last (modulo N).
// Could also use "invariant:" keyword.
(future & closed)
  (forall i <- Nat % N :
   (x[i]+1) % N == x[i+1]);

