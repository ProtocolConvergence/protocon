
// The Dining Philosophers Problem allowing randomized actions.

constant N := 3;

variable hungry[Nat % N] <- Nat % 2;
variable chopstick[Nat % (2*N)] <- Nat % 2;
variable b[Nat % N] <- Nat % 2;

// Converge to a state where no philosopher is hungry or has a chopstick.
(future & future silent)
  (forall i <- Nat % N : 1==1
   && hungry[i]==0
   && chopstick[2*i  ]==0
   && chopstick[2*i+1]==0
  );

process P[i <- Nat % N]
{
  let L := 2*i;
  let R := 2*i+1;


  // Whether the philosopher is hungry.
  write: hungry[i];

  read: chopstick[L-1];
  write: chopstick[L];
  write: chopstick[R];
  read: chopstick[R+1];

  // Random value to influence decisions.
  random write: b[i];


  // Assume two philosophers can't have the same chopstick.
  (assume & closed)
    (chopstick[2*i+1]==0 || chopstick[2*i+2]==0);


  predicate Have2 :=
    (chopstick[L] + chopstick[R] == 2);


  // Permit actions where hungry status is not changed.
  // (But only those that are not also forbidden.)
  permit:
    ( 1==1 --> hungry[i]; )
    ;

  // Can only change to be not hungry when having chopsticks.
  // The chopsticks are not given up during this step.
  permit:
    ( Have2 && hungry[i]==1 --> hungry[i]:=0; _; )
    ;

  // Forbid changing position of both chopsticks at the same time.
  forbid:
    ( 1==1 --> chopstick[L]:=1-chopstick[L]; chopstick[R]:=1-chopstick[R]; )
    ;

  puppet:
    // Use randomization to choose when nobody has a chopstick.
    ( hungry[i]==1 && chopstick[L-1]==0 && chopstick[L]==0 && chopstick[R]==0 && chopstick[R+1]==0 && b[i]==0 --> chopstick[R]:=1; b[i]:=_; )
    ( hungry[i]==1 && chopstick[L-1]==0 && chopstick[L]==0 && chopstick[R]==0 && chopstick[R+1]==0 && b[i]==1 --> chopstick[L]:=1; b[i]:=_; )

    // No random choice, but still hungry.
    ( hungry[i]==1 && chopstick[L-1]==1 && chopstick[R]==1 --> chopstick[R]:=0; b[i]:=_; )
    ( hungry[i]==1 && chopstick[L]==1 && chopstick[R+1]==1 --> chopstick[L]:=0; b[i]:=_; )
    ( hungry[i]==1 && chopstick[L]==1 && chopstick[R]==0 && chopstick[R+1]==0 --> chopstick[R]:=1; b[i]:=_; )
    ( hungry[i]==1 && chopstick[L-1]==0 && chopstick[L]==0 && chopstick[R]==1 --> chopstick[L]:=1; b[i]:=_; )

    // Eat.
    ( hungry[i]==1 && chopstick[L]==1 && chopstick[R]==1 --> hungry[i]:=0; b[i]:=_; )

    // Put down chopsticks.
    ( hungry[i]==0 && chopstick[L]==0 && chopstick[R]==1 --> chopstick[R]:=0; b[i]:=_; )
    ( hungry[i]==0 && chopstick[L]==1 && chopstick[R]==1 --> chopstick[R]:=0; b[i]:=_; )
    ( hungry[i]==0 && chopstick[L]==1 && chopstick[R]==0 --> chopstick[L]:=0; b[i]:=_; )
    ;
}

