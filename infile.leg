
%{
#include "cx/synhax.hh"

extern "C" {
#include "cx/alphatab.h"
#include "cx/fileb.h"
#include "cx/lsp.h"
}

#define YYSTYPE Lsp
#define YY_CTX_LOCAL
#define YY_CTX_MEMBERS  LspCtx* spctx;  FILE* infile;  const char* negprefix;
#define YY_INPUT(buf, result, max_size) \
{ \
  int yyc = fgetc(ctx->infile); \
  result= (EOF == yyc) ? 0 : (*(buf) = yyc, 1); \
}

%}

FinFile =
  WS? Protocol
  (WS? ConstDecl)*
  (WS? VarDecl)+
  (WS? ProcDecl)+
  WS? END_OF_FILE
  { puts("parsed!"); }

Protocol = 'protocol' WS name:ID WS? ';' {}

ConstDecl = 'constant' WS name:ID WS? '=' WS? v:NAT WS? ';' {}

VarDecl =
  'variable' WS name:ID '(' WS? len:NatDom WS? ')' WS? ':' WS? dom:NatDom WS? ';'
  {$$ = list4_ccstr_Lsp ("decl", dom, name, len);}

ProcDecl =
  'process' WS pc_name:ID '(' WS? idx_name:ID WS? ':' WS? npcs:NatDom WS? ')'
  WS? '{'
  WS? 'read:' WS? VblRef (WS? ',' WS? VblRef)* WS? ';'
  WS? 'write:' WS?  VblRef (WS? ',' WS? VblRef)* WS? ';'
  WS? 'legit:' WS? Expr WS? ';'
  WS? '}'

ConstExpr =
    a:NAT {$$ = a;}
  | b:ID {$$ = b;}

Expr = a:Disjunction {$$ = a;}

Disjunction =
  a:Conjunction
  (WS? '||' WS? b:Conjunction {a = list3_ccstr_Lsp ("||", a, b);} )*
  {$$ = a;}

Conjunction =
  a:Comparison
  (WS? '&&' WS? b:Comparison {a = list3_ccstr_Lsp ("&&", a, b);} )*
  {$$ = a;}

Comparison =
  a:Sum
  (  (WS? '==' WS? b:Sum {a = list3_ccstr_Lsp ("==", a, b);} )
   | (WS? '!=' WS? b:Sum {a = list3_ccstr_Lsp ("!=", a, b);} )
  )?
  {$$ = a;}

Sum =
  a:Product
  (  (WS? '+' WS? b:Product {a = list3_ccstr_Lsp ("+", a, b);} )
   | (WS? '-' WS? b:Product {a = list3_ccstr_Lsp ("-", a, b);} )
  )*
  {$$ = a;}

Product =
  a:Neg
  (  (WS? '*' WS? b:Neg {a = list3_ccstr_Lsp ("*", a, b);} )
   | (WS? '/' WS? b:Neg {a = list3_ccstr_Lsp ("/", a, b);} )
   | (WS? '%' WS? b:Neg {a = list3_ccstr_Lsp ("%", a, b);} )
  )*
  {$$ = a;}

Neg =
  (   '-' {ctx->negprefix = "-";}
   | '!' {ctx->negprefix = "!";}
  )? a:Value
  {$$ = a;  if (ctx->negprefix)  $$ = list2_ccstr_Lsp (ctx->negprefix, $$);}

Value =
    a:VblRef {$$ = a;}
  | a:NAT {$$ = a;}
  | '(' WS? a:Expr WS? ')'
    {$$ = list2_ccstr_Lsp ("()", a);}

VblRef =
  a:ID
  ('(' WS? b:Expr WS? ')'
   {a = list3_ccstr_Lsp ("aref", a, b);}
  )?
  {$$ = a;}


NatDom =
  'Nat(' WS? a:ConstExpr WS? ')'
  {$$ = a;}

NAT = < [0-9]+ >
  {
    uint u;
    xget_uint_cstr (&u, yytext);
    $$ = make_Nat_Lsp (ctx->spctx, u);
  }

ID = < [A-Za-z][0-9A-Za-z]* >
  {
    $$ = make_String_Lsp (ctx->spctx, yytext);
  }
LINE_COMMENT = '//' [^\n]* [\n] {}
WS = ([ \t\r\n]+ | LINE_COMMENT)+ {}
END_OF_FILE = !.

%%

void ParseMyThings(const char* fname)
{
  yycontext yyctx;
  memset (&yyctx, 0, sizeof (yyctx));
  yyctx.spctx = make_LspCtx ();
  yyctx.infile = fopen(fname, "rb");
  while (yyparse(&yyctx))
    ;
  free_LspCtx (yyctx.spctx);
  fclose(yyctx.infile);
  free(yyctx.buf);
  free(yyctx.thunks);
  free(yyctx.text);
  free(yyctx.vals);
}

