
%{
#include "cx/synhax.hh"

extern "C" {
#include "cx/fileb.h"
}
#include "protoconfile.hh"

#define YYSTYPE FinMeta
#define YY_CTX_LOCAL
#define YY_CTX_MEMBERS \
  ProtoconFile* st;

//  int yyc = fgetc(yy->infile);
//  result= (EOF == yyc) ? 0 : (*(buf) = yyc, 1);

#define YY_INPUT(yy, buf, result, max_size) \
{ \
  result = xget_char_XFile (&yy->st->xf, buf) ? 1 : 0; \
}
%}

ProtoconFile =
  (WS? Protocol)?
  (WS? ConstDecl)*
  (WS? VarDecl)+
  (WS? ProcDecl)+
  (WS? NamedPredicate)*
  (WS? GlobalLegit)?
  WS? END_OF_FILE
  ;

Protocol = 'protocol' WS name:ID END_STMT {}
  ;

ConstDecl =
  'constant' WS name:ID WS? ':=' WS? v:ConstExpr END_STMT
  {
    yy->st->add_constant(name.sp, v.sp);
  }
  ;

OptionalShadowPuppetRole =
  {$$.sp = 0;}
  (  'shadow' WS {$$.sp = make_ccstr_Sesp (yy->st->spctx, "shadow");}
   | 'puppet' WS {$$.sp = make_ccstr_Sesp (yy->st->spctx, "puppet");}
   | 'direct' WS
  )?
  ;

VarDecl =
  r:OptionalShadowPuppetRole 'variable'
  WS a:ID '[' WS? b:NatDom WS? ']' WS? IN WS? c:NatDom END_STMT
  {
    Xn::Vbl::ShadowPuppetRole role = Xn::Vbl::Direct;
    if (pfxeq_cstr ("shadow", ccstr_of_Sesp (r.sp))) {
      role = Xn::Vbl::Shadow;
    }
    else if (pfxeq_cstr ("puppet", ccstr_of_Sesp (r.sp))) {
      role = Xn::Vbl::Puppet;
    }
    if (r.sp)  lose_Sesp (r.sp);
    yy->st->add_variables(a.sp, b.sp, c.sp, role);
  }
  ;

ActionExpr =
  '(' WS?
   act:Expr WS? '-->' WS?  {act.sp = list2_ccstr_Sesp ("-->", act.sp);}
   (vbl:VblRef WS? ':=' WS?
    (  val:Expr
       {pushlast_Sesp (act.sp, list3_ccstr_Sesp (":=", vbl.sp, val.sp));}
     | val_wild:WILD
       {pushlast_Sesp (act.sp, list3_ccstr_Sesp (":=", vbl.sp, val_wild.sp));}
    )
    END_STMT WS?
   )+
   ')'
   {$$ = act;}
   ;

ShadowActionDef =
  'shadow' (WS ACTION | ':') WS? act:ActionExpr
  {yy->st->add_action (act.sp, Xn::Vbl::Shadow);}
  (WS? (',' WS?)? act2:ActionExpr {yy->st->add_action (act2.sp, Xn::Vbl::Shadow);} )*
  END_STMT
  ;

DirectActionDef =
  ('direct:' | ('direct' WS)? ACTION) WS? act:ActionExpr
  {yy->st->add_action (act.sp, Xn::Vbl::Direct);}
  (WS? (',' WS?)? act2:ActionExpr {yy->st->add_action (act2.sp, Xn::Vbl::Direct);} )*
  END_STMT
  ;

PuppetActionDef =
  'puppet' (WS ACTION | ':') WS? act:ActionExpr
  {yy->st->add_action (act.sp, Xn::Vbl::Puppet);}
  (WS? (',' WS?)? act2:ActionExpr {yy->st->add_action (act2.sp, Xn::Vbl::Puppet);} )*
  END_STMT
  ;

ForbidActionDef =
  'forbid' (WS ACTION | ':') WS? act:ActionExpr
  {yy->st->forbid_action (act.sp);}
  (WS? (',' WS?)? act2:ActionExpr {yy->st->forbid_action (act2.sp);} )*
  END_STMT
  ;

ProcDecl =
  'process' WS pc_name:ID '[' WS? idx_name:ID WS? IN WS? npcs:NatDom WS? ']'
  {yy->st->add_processes(pc_name.sp, idx_name.sp, npcs.sp);}
  WS? '{' WS?
  ( 'let' WS let_name:ID WS? ':=' WS? let_val:Expr END_STMT WS?
    {yy->st->add_let(let_name.sp, let_val.sp);}
  )*
  ( (  'read:'  WS? u:VblRef WS?  {yy->st->add_access(u.sp, 0);}
       (','     WS? v:VblRef WS?  {yy->st->add_access(v.sp, 0);} )*
     | 'write:' WS? u:VblRef WS?  {yy->st->add_access(u.sp, 1);}
       (','     WS? v:VblRef WS?  {yy->st->add_access(v.sp, 1);} )*
    )
    END_STMT WS?
    |
    SymmetricAccess WS?
  )+
  ((ShadowActionDef | DirectActionDef | PuppetActionDef | ForbidActionDef)
   WS?
  )*
  ( LEGIT WS? legit:Expr END_STMT WS?
    {yy->st->add_pc_legit(legit.sp);}
  )?
  {
    yy->st->pc_symm = 0;
    yy->st->pc_symm_spec = 0;
  }
  '}'
  ;

SymmetricAccess =
  'for' WS let_name:ID WS? IN WS?
  '{#' WS? let_vals:Expr  {let_vals.sp = list1_Sesp (let_vals.sp);}
   WS? (',' WS? let_val:Expr  {pushlast_Sesp (let_vals.sp, let_val.sp);} WS?)*
  '#}' WS?
  '{' WS?
  {
    yy->st->pc_symm_spec->oblivious_specs.push(Xn::ObliviousSpec(sz_of_Sesp (let_vals.sp)));
    Xn::ObliviousSpec& obliv_spec = yy->st->pc_symm_spec->oblivious_specs.top();
    obliv_spec.let_expression = ccstr_of_Sesp (let_name.sp);

    Sesp vals_sp = let_vals.sp;
    while (!nil_ck_Sesp (vals_sp)) {
      if (!obliv_spec.multiset_expression.empty_ck()) {
        obliv_spec.multiset_expression += ", ";
      }
      Cx::String val_expression;
      yy->st->string_expression(val_expression, car_of_Sesp (vals_sp));
      obliv_spec.multiset_expression += val_expression;
      vals_sp = cdr_of_Sesp (vals_sp);
    }
  }
  ( (  'read:'  WS? u:VblRef WS?  {u.sp = list2_ccstr_Sesp ("r", u.sp);}
       (','     WS? v:VblRef WS?  {pushlast_Sesp (u.sp, v.sp);} )*
     | 'write:' WS? u:VblRef WS?  {u.sp = list2_ccstr_Sesp ("w", u.sp);}
       (','     WS? v:VblRef WS?  {pushlast_Sesp (u.sp, v.sp);} )*
    )
    END_STMT WS?
    {
      Xn::ObliviousSpec& obliv_spec = yy->st->pc_symm_spec->oblivious_specs.top();
      Sesp vbls_sp = u.sp;
      Bool own = eq_cstr ("w", ccstr_of_Sesp (car_of_Sesp (vbls_sp)));
      vbls_sp = cdr_of_Sesp (vbls_sp);

      while (!nil_ck_Sesp (vbls_sp)) {
        Sesp vals_sp = let_vals.sp;
        Cx::Table<uint> vbl_idcs;
        while (!nil_ck_Sesp (vals_sp)) {
          yy->st->add_scope_let(let_name.sp, car_of_Sesp (vals_sp));
          vbl_idcs.push(yy->st->pc_symm_spec->rvbl_symms.sz());
          yy->st->add_access(car_of_Sesp (vbls_sp), own ? 1 : 0);
          vals_sp = cdr_of_Sesp (vals_sp);
          yy->st->del_scope_let(let_name.sp);
        }

        Cx::String index_expression;
        yy->st->string_expression(index_expression, caddar_of_Sesp (vbls_sp));
        obliv_spec.add_oblivious(vbl_idcs, index_expression);
        vbls_sp = cdr_of_Sesp (vbls_sp);
      }
    }
  )+
 '}'
  ;

NamedPredicate =
  'predicate' WS name:ID WS? ':=' WS? a:Expr END_STMT
  {yy->st->add_predicate(name.sp, a.sp);}
  ;

GlobalLegit =
  (  'shadow' (WS LEGIT | ':') {yy->st->sys->direct_invariant_flag = false;}
   | 'direct' (WS LEGIT | ':')
   | LEGIT
  )
  WS? a:Expr END_STMT
  {yy->st->add_legit(a.sp);}
  ;

ConstExpr = a:ConstSum {$$ = a;}
  ;

ConstSum =
  a:ConstProduct
  (  (WS? '+' WS? b:ConstProduct {a.sp = list3_ccstr_Sesp ("+", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '-' WS? b:ConstProduct {a.sp = list3_ccstr_Sesp ("-", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}
  ;

ConstProduct =
  a:ConstNeg
  (  (WS? '*' WS? b:ConstNeg {a.sp = list3_ccstr_Sesp ("*", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '/' WS? b:ConstNeg {a.sp = list3_ccstr_Sesp ("/", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '%' WS? b:ConstNeg {a.sp = list3_ccstr_Sesp ("%", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}
  ;

OptionalArithNeg =
  {$$.sp = 0;}
  ( '-' WS? {$$.sp = make_ccstr_Sesp (yy->st->spctx, "negate");} )?
  ;

ConstNeg =
  pfx:OptionalArithNeg a:ConstPower
  {
    $$ = a;
    if (pfx.sp)
      $$.sp = list2_Sesp (pfx.sp, $$.sp);
  }
  ;

ConstPower =
  a:ConstValue
  (  (WS? '^' WS? b:ConstNeg {a.sp = list3_ccstr_Sesp ("^", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}
  ;

ConstValue =
    a:NAT {$$ = a;}
  | a:ID {$$ = a; }
  | '(' WS? a:ConstExpr WS? ')'
    {
      $$.sp = list2_ccstr_Sesp ("(int)", a.sp);
      $$.int_ck = a.int_ck;
    }
  ;


Expr =
    a:Quantify {$$ = a;}
  | a:IfThenElse {$$ = a;}
  | a:Implication {$$ = a;}
  ;

IfThenElse =
  'if'   WS a:Expr WS
  'then' WS b:Expr WS
  'else' WS c:Expr
  {
    $$.sp = list4_ccstr_Sesp ("iif", a.sp, b.sp, c.sp);
    Claim2( b.int_ck ,==, 1 );
    Claim2( c.int_ck ,==, 1 );
    $$.int_ck = 1;
  }

Quantify =
    'forall' WS a:ID WS? IN WS? b:NatDom WS? ':' WS? c:Expr
    {
      $$.sp = list4_ccstr_Sesp ("forall", a.sp, b.sp, c.sp);
      $$.int_ck = 0;
    }
  | 'exists' WS a:ID WS? IN WS? b:NatDom WS? ':' WS? c:Expr
    {
      $$.sp = list4_ccstr_Sesp ("exists", a.sp, b.sp, c.sp);
      $$.int_ck = 0;
    }
  | 'unique' WS a:ID WS? IN WS? b:NatDom WS? ':' WS? c:Expr
    {
      $$.sp = list4_ccstr_Sesp ("unique", a.sp, b.sp, c.sp);
      $$.int_ck = 0;
    }
  ;

Implication =
  a:Disjunction
  (WS? '=>' WS? b:Disjunction {a.sp = list3_ccstr_Sesp ("=>", a.sp, b.sp);  a.int_ck = 0;} )*
  {$$ = a;}
  ;

Disjunction =
  a:Conjunction
  (WS? '||' WS? b:Conjunction {a.sp = list3_ccstr_Sesp ("||", a.sp, b.sp);  a.int_ck = 0;} )*
  {$$ = a;}
  ;

Conjunction =
  a:Comparison
  (WS? '&&' WS? b:Comparison {a.sp = list3_ccstr_Sesp ("&&", a.sp, b.sp);  a.int_ck = 0;} )*
  {$$ = a;}
  ;

Comparison =
  a:Sum
  (  (WS? '==' WS? b:Sum {a.sp = list3_ccstr_Sesp ((b.int_ck ? "==" : "xnor"), a.sp, b.sp);  a.int_ck = 0;} )
   | (WS? '!=' WS? b:Sum {a.sp = list3_ccstr_Sesp ((b.int_ck ? "!=" :  "xor"), a.sp, b.sp);  a.int_ck = 0;} )
   | (WS? '<=' WS? b:Sum {a.sp = list3_ccstr_Sesp ("<=", a.sp, b.sp);  a.int_ck = 0;} )
   | (WS? '>=' WS? b:Sum {a.sp = list3_ccstr_Sesp (">=", a.sp, b.sp);  a.int_ck = 0;} )
   | (WS? '<'  WS? b:Sum {a.sp = list3_ccstr_Sesp ("<", a.sp, b.sp);  a.int_ck = 0;} )
   | (WS? '>'  WS? b:Sum {a.sp = list3_ccstr_Sesp (">", a.sp, b.sp);  a.int_ck = 0;} )
  )?
  {$$ = a;}
  ;

Sum =
  a:Product
  (  (WS? '+' WS? b:Product {a.sp = list3_ccstr_Sesp ("+", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '-' WS? b:Product {a.sp = list3_ccstr_Sesp ("-", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}
  ;

Product =
  a:Neg
  (  (WS? '*' WS? b:Neg {a.sp = list3_ccstr_Sesp ("*", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '/' WS? b:Neg {a.sp = list3_ccstr_Sesp ("/", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '%' WS? b:Neg {a.sp = list3_ccstr_Sesp ("%", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}
  ;

OptionalNeg =
  {$$.sp = 0;}
  (   '-' WS? {$$.sp = make_ccstr_Sesp (yy->st->spctx, "negate");}
    | '!' WS? {$$.sp = make_ccstr_Sesp (yy->st->spctx, "!");}
  )?
  ;

Neg =
  pfx:OptionalNeg a:Power
  {
    $$ = a;
    if (pfx.sp)
      $$.sp = list2_Sesp (pfx.sp, $$.sp);
  }

Power =
  a:Value
  (  (WS? '^' WS? b:Neg {a.sp = list3_ccstr_Sesp ("^", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}
  ;

Value =
    a:VblRef {$$ = a;}
  | a:NAT {$$ = a;}
  | '(' WS? a:Expr WS? ')'
    {
      $$.sp = list2_ccstr_Sesp (a.int_ck ? "(int)" : "(bool)", a.sp);
      $$.int_ck = a.int_ck;
    }
  ;

VblRef =
  a:ID
  ('[' WS? b:Expr WS? ']'
   {a.sp = list3_ccstr_Sesp ("aref", a.sp, b.sp);}
  )?
  {
    $$ = a;
    $$.int_ck = 1;
  }
  ;

NatDom =
  ('Int' | 'Nat') WS? '%' WS? a:ConstValue
  {
    $$.sp = list2_ccstr_Sesp ("NatDom", a.sp);
    $$.int_ck = 1;
  }
  ;

NAT = < [0-9]+ >
  {
    uint u;
    xget_uint_cstr (&u, yytext);
    $$.sp = make_Nat_Sesp (yy->st->spctx, u);
    $$.int_ck = 1;
  }
  ;

IN = '<-'
  ;


EVENTUALLY_ALWAYS = 'eventually' WS 'always'
  ;

EVENTUALLY_AND_INVARIANT =
  'eventually' WS? '&' WS? 'invariant'
  ;

LEGIT =
  'legit:' | 'invariant:'
  ;

ACTION = 'act:' | 'action:' ;

END_STMT = WS? ';' ;

WILD = '_'
  {
    $$.sp = list1_Sesp (make_ccstr_Sesp (yy->st->spctx, "wild"));
    $$.int_ck = 1;
  }

ID = < [A-Za-z][0-9A-Za-z_]* >
  {
    $$.sp = make_cstr_Sesp (yy->st->spctx, yytext);
    $$.int_ck = 1;
  }
  ;
LINE_COMMENT = '//' [^\n]* [\n] { yy->st->text_nlines += 1; }
  ;
WHITE_SPACE = ( [ \t\r] | [\n] { yy->st->text_nlines += 1; } )+
  ;
WS = (WHITE_SPACE | LINE_COMMENT)+ {}
  ;
END_OF_FILE = !.
  ;

%%

  bool
ReadProtoconFile(Xn::Sys& sys, const ProtoconFileOpt& opt)
{
  bool good = true;
  yycontext yyctx;
  memset (&yyctx, 0, sizeof (yyctx));
  Claim(!opt.file_path.empty_ck());
  XFileB xfb;
  init_XFileB (&xfb);
  open_FileB (&xfb.fb, 0, opt.file_path.cstr());
  //yyctx.infile = fopen(opt.file_path.cstr(), "rb");
  yyctx.st = new ProtoconFile(&sys, &xfb.xf);
  for (Cx::Map<Cx::String,uint>::const_iterator itr = opt.constant_map.begin();
       itr != opt.constant_map.end();
       ++itr)
  {
    Xn::NatMap x(1);
    x.membs[0] = itr->second;
    x.expression = x.membs[0];
    yyctx.st->sys->spec->constant_map.add(itr->first, x);
  }
  if (!yyparse(&yyctx) || !yyctx.st->allgood) {
    good = false;
    DBog1( "Error parsing the file: %s", opt.file_path.cstr() );
  }
  lose_XFileB (&xfb);
  delete yyctx.st;
  yyrelease(&yyctx);
  sys.commit_initialization();
  return good;
}

