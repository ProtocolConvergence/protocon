
%{
#include "cx/synhax.hh"

extern "C" {
#include "cx/fileb.h"
}
#include "protoconfile.hh"

#define YYSTYPE FinMeta
#define YY_CTX_LOCAL
#define YY_CTX_MEMBERS \
  FILE* infile; \
  ProtoconFile* st;

#define YY_INPUT(yy, buf, result, max_size) \
{ \
  int yyc = fgetc(yy->infile); \
  result= (EOF == yyc) ? 0 : (*(buf) = yyc, 1); \
}
%}

ProtoconFile =
  (WS? Protocol)?
  (WS? ConstDecl)*
  (WS? VarDecl)+
  (WS? ProcDecl)+
  (WS? GlobalLegit)?
  WS? END_OF_FILE

Protocol = 'protocol' WS name:ID WS? ';' {}

ConstDecl =
  'constant' WS name:ID WS? ':=' WS? v:ConstExpr WS? ';'
  {
    bool legit = true;
    int x = 0;
    if (LegitCk( yy->st->eval_int (&x, v.sp), legit, "" )) {
      if (LegitCk( x >= 0, legit, "" )) {
        yy->st->constant_map[ccstr_of_Sesp (name.sp)] = (uint) x;
      }
    }
  }

OptionalShadowPuppetRole =
  {$$.sp = 0;}
  (  'shadow' WS {$$.sp = make_ccstr_Sesp (yy->st->spctx, "shadow");}
   | 'puppet' WS {$$.sp = make_ccstr_Sesp (yy->st->spctx, "puppet");}
   | 'direct' WS
  )?

VarDecl =
  r:OptionalShadowPuppetRole 'variable'
  WS a:ID '[' WS? b:NatDom WS? ']' WS? IN WS? c:NatDom WS? ';'
  {
    Xn::Vbl::ShadowPuppetRole role = Xn::Vbl::Direct;
    if (pfxeq_cstr ("shadow", ccstr_of_Sesp (r.sp))) {
      role = Xn::Vbl::Shadow;
    }
    else if (pfxeq_cstr ("puppet", ccstr_of_Sesp (r.sp))) {
      role = Xn::Vbl::Puppet;
    }
    if (r.sp)  lose_Sesp (r.sp);
    yy->st->add_variables(a.sp, b.sp, c.sp, role);
  }

ProcDecl =
  'process' WS pc_name:ID '[' WS? idx_name:ID WS? IN WS? npcs:NatDom WS? ']'
  {yy->st->add_processes(pc_name.sp, idx_name.sp, npcs.sp);}
  WS? '{' WS?
  ( 'let' WS let_name:ID WS? ':=' WS? let_val:Expr WS? ';' WS?
    {yy->st->add_let(let_name.sp, let_val.sp);}
  )*
  ( (  'read:'  WS?  u:VblRef  {yy->st->add_access(u.sp, idx_name.sp, 0);}
       (WS? ',' WS? v:VblRef  {yy->st->add_access(v.sp, idx_name.sp, 0);} )*
     | 'write:' WS?  u:VblRef  {yy->st->add_access(u.sp, idx_name.sp, 1);}
       (WS? ',' WS? v:VblRef  {yy->st->add_access(v.sp, idx_name.sp, 1);} )*
    )
    WS? ';' WS?
  )+
  ( 'act:' WS?  '(' WS?
    act:Expr WS? '-->' WS?  {act.sp = list2_ccstr_Sesp ("-->", act.sp);}
    ( vbl:VblRef WS? ':=' WS? val:Expr WS? ';' WS?
      {pushlast_Sesp (act.sp, list3_ccstr_Sesp (":=", vbl.sp, val.sp));}
    )+
    ')' WS? ';' WS?
    {yy->st->add_action (act.sp, idx_name.sp);}
  )*
  ( INVARIANT WS? legit:Expr WS? ';' WS?
    {yy->st->add_legit(legit.sp, idx_name.sp);}
  )?
  {yy->st->let_map.clear();}
  '}'

GlobalLegit =
  INVARIANT WS? a:Expr WS? ';'
  {yy->st->add_legit(a.sp);}

ConstExpr = a:ConstSum {$$ = a;}

ConstSum =
  a:ConstProduct
  (  (WS? '+' WS? b:ConstProduct {a.sp = list3_ccstr_Sesp ("+", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '-' WS? b:ConstProduct {a.sp = list3_ccstr_Sesp ("-", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}

ConstProduct =
  a:ConstNeg
  (  (WS? '*' WS? b:ConstNeg {a.sp = list3_ccstr_Sesp ("*", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '/' WS? b:ConstNeg {a.sp = list3_ccstr_Sesp ("/", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '%' WS? b:ConstNeg {a.sp = list3_ccstr_Sesp ("%", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}

OptionalArithNeg =
  {$$.sp = 0;}
  ( '-' WS? {$$.sp = make_ccstr_Sesp (yy->st->spctx, "negate");} )?

ConstNeg =
  pfx:OptionalArithNeg a:ConstValue
  {
    $$ = a;
    if (pfx.sp)
      $$.sp = list2_Sesp (pfx.sp, $$.sp);
  }

ConstValue =
    a:NAT {$$ = a;}
  | a:ID {$$ = a;}
  | '(' WS? a:ConstExpr WS? ')'
    {
      $$.sp = list2_ccstr_Sesp ("(int)", a.sp);
      $$.int_ck = a.int_ck;
    }


Expr =
    a:Quantify {$$ = a;}
  | a:Disjunction {$$ = a;}

Quantify =
    'forall' WS a:ID WS? IN WS? b:NatDom WS? ':' WS? c:Expr
    {
      $$.sp = list4_ccstr_Sesp ("forall", a.sp, b.sp, c.sp);
      $$.int_ck = 0;
    }
  | 'exists' WS a:ID WS? IN WS? b:NatDom WS? ':' WS? c:Expr
    {
      $$.sp = list4_ccstr_Sesp ("exists", a.sp, b.sp, c.sp);
      $$.int_ck = 0;
    }
  | 'unique' WS a:ID WS? IN WS? b:NatDom WS? ':' WS? c:Expr
    {
      $$.sp = list4_ccstr_Sesp ("unique", a.sp, b.sp, c.sp);
      $$.int_ck = 0;
    }

Disjunction =
  a:Conjunction
  (WS? '||' WS? b:Conjunction {a.sp = list3_ccstr_Sesp ("||", a.sp, b.sp);  a.int_ck = 0;} )*
  {$$ = a;}

Conjunction =
  a:Comparison
  (WS? '&&' WS? b:Comparison {a.sp = list3_ccstr_Sesp ("&&", a.sp, b.sp);  a.int_ck = 0;} )*
  {$$ = a;}

Comparison =
  a:Sum
  (  (WS? '==' WS? b:Sum {a.sp = list3_ccstr_Sesp ((b.int_ck ? "==" : "xnor"), a.sp, b.sp);  a.int_ck = 0;} )
   | (WS? '!=' WS? b:Sum {a.sp = list3_ccstr_Sesp ((b.int_ck ? "!=" :  "xor"), a.sp, b.sp);  a.int_ck = 0;} )
  )?
  {$$ = a;}

Sum =
  a:Product
  (  (WS? '+' WS? b:Product {a.sp = list3_ccstr_Sesp ("+", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '-' WS? b:Product {a.sp = list3_ccstr_Sesp ("-", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}

Product =
  a:Neg
  (  (WS? '*' WS? b:Neg {a.sp = list3_ccstr_Sesp ("*", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '/' WS? b:Neg {a.sp = list3_ccstr_Sesp ("/", a.sp, b.sp);  a.int_ck = 1;} )
   | (WS? '%' WS? b:Neg {a.sp = list3_ccstr_Sesp ("%", a.sp, b.sp);  a.int_ck = 1;} )
  )*
  {$$ = a;}

OptionalNeg =
  {$$.sp = 0;}
  (   '-' WS? {$$.sp = make_ccstr_Sesp (yy->st->spctx, "negate");}
    | '!' WS? {$$.sp = make_ccstr_Sesp (yy->st->spctx, "!");}
  )?

Neg =
  pfx:OptionalNeg a:Value
  {
    $$ = a;
    if (pfx.sp)
      $$.sp = list2_Sesp (pfx.sp, $$.sp);
  }

Value =
    a:VblRef {$$ = a;}
  | a:NAT {$$ = a;}
  | '(' WS? a:Expr WS? ')'
    {
      $$.sp = list2_ccstr_Sesp (a.int_ck ? "(int)" : "(bool)", a.sp);
      $$.int_ck = a.int_ck;
    }

VblRef =
  a:ID
  ('[' WS? b:Expr WS? ']'
   {a.sp = list3_ccstr_Sesp ("aref", a.sp, b.sp);}
  )?
  {
    $$ = a;
    $$.int_ck = 1;
  }

NatDom =
  ('Int' | 'Nat') WS? '%' WS? a:ConstValue
  {
    $$.sp = list2_ccstr_Sesp ("NatDom", a.sp);
    $$.int_ck = 1;
  }

NAT = < [0-9]+ >
  {
    uint u;
    xget_uint_cstr (&u, yytext);
    $$.sp = make_Nat_Sesp (yy->st->spctx, u);
    $$.int_ck = 1;
  }

IN = ':'

INVARIANT = 'invariant:'

ID = < [A-Za-z][0-9A-Za-z]* >
  {
    const uint* x = yy->st->constant_map.lookup(yytext);
    if (x) {
      $$.sp = make_Nat_Sesp (yy->st->spctx, *x);
    }
    else {
      $$.sp = make_cstr_Sesp (yy->st->spctx, yytext);
    }
    $$.int_ck = 1;
  }
LINE_COMMENT = '//' [^\n]* [\n] {}
WS = ([ \t\r\n]+ | LINE_COMMENT)+ {}
END_OF_FILE = !.

%%

bool ReadProtoconFile(Xn::Sys& sys, const char* fname)
{
  bool good = true;
  yycontext yyctx;
  memset (&yyctx, 0, sizeof (yyctx));
  yyctx.infile = fopen(fname, "rb");
  yyctx.st = new ProtoconFile(&sys);
  if (!yyparse(&yyctx) || !yyctx.st->allgood) {
    good = false;
    DBog1( "Error parsing the file: %s", fname );
  }
  delete yyctx.st;
  fclose(yyctx.infile);
  yyrelease(&yyctx);
  sys.commit_initialization();
  return good;
}

