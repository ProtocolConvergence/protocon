
constant N := 6;
constant M := 4;

variable x[Nat % N] <- Nat % M;
variable way[Nat % (2*N)] <- Nat % 2;

process P[i <- Nat % N]
{
  let idx0_even := (N-1-i)/2;
  let idx1_even := idx0_even + N/2;

  let idx0_odd  := (N-1)/2 * (i + 1);
  let idx1_odd  := (N-1)/2 * (i + 2);

  let idx0_tmp := if (N % 2 == 0) then (idx0_even) else (idx0_odd);
  let idx1_tmp := if (N % 2 == 0) then (idx1_even) else (idx1_odd);

  let idx0 := if (idx0_tmp % N != i) then (idx0_tmp) else (idx1_tmp);
  let idx1 := if (idx1_tmp % N != i) then (idx1_tmp) else (idx0_tmp);

  symmetric (lhs_idx, x_idx) <- {# (2*i, idx0), (2*i+1, idx1) #}
  {
    read: way[lhs_idx];
    read: x[x_idx];
  }
  write: x[i];
  forbid: ( way[2*i]==way[2*i+1] --> _; );
}

process OrientLink[i <- Nat % (2*N)]
{
  let j := if (i % 2 == 0) then (i+1) else (i-1);
  read: way[j];
  write: way[i];
  puppet action:
    ( way[i] == way[j] --> way[i] := 1-way[j]; )
    ;
}

invariant:
  (forall i <- Nat % N : way[2*i] != way[2*i+1])
  &&
  (forall i <- Nat % N :
   (forall q <- Nat % 2 :
    (i == -(2*i + q+1) % N)
    ||
    (x[i] != x[-(2*i + q+1)])
   )
  )
  ;

